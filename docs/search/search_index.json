{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"from pyobjson import PythonObjectJson pyobjson - Python Object JSON Tool \u00b6 Utility library for serializing/deserializing custom Python objects to/from JSON. Do you like the Python Object JSON Tool? Star the repository on GitHub and please consider helping support its ongoing development: READ THE DOCS HERE! Detailed documentation can be found at https://pyobjson.wrencode.dev . Table of Contents \u00b6 About Installation Dependencies Toolchain Usage JSON Example JSON Example Output Saving and Loading JSON Files JSON File Example JSON File Output MongoDB MongoDB Example MongoDB Output About \u00b6 The Python Object JSON Tool is a utility library for serializing/deserializing custom Python objects to/from JSON by using pyobjson classes as superclasses/parent classes to your custom Python classes. Installation \u00b6 You can install with pip by running: pip install pyobjson Note : If you wish to use pyobjson to serialize/deserialize custom Python objects to/from MongoDB, then you have to install with the optional dependencies: pip install pyobjson [ mongo ] Dependencies \u00b6 The base Python Object JSON Tool does not have any third-party dependencies to run the code. It has several development dependencies, which can be seen in the package pyproject.toml . If you wish to use pyobjson to serialize/deserialize custom Python objects to/from MongoDB, then there is an additional dependency on the PyMongo package. Toolchain \u00b6 The below tools and resources are used as part of pyobjson: uv - package management ruff - code linting bandit - code security make - Makefile build automation MkDocs - package documentation python-dotenv - programmatic access to environment variables defined in a .env file pytest - code testing framework GitHub Actions - CI/CD act - GitHub Actions testing Usage \u00b6 The pyobjson package is designed to be used as a base class/parent class/superclass to your own custom Python classes in order to provide built-in, convenient serialization/deserialization functionality. Child classes/subclasses of pyobjson.base.PythonObjectJson will automatically have the following methods: pyobjson.base.PythonObjectJson.serialize() : Create a serializable dictionary from the class instance. pyobjson.base.PythonObjectJson.to_json_str() : Serialize the class instance to a JSON string. pyobjson.base.PythonObjectJson.from_json_str(json_str) : Load the class instance from a pyobjson -formatted JSON string. pyobjson.base.PythonObjectJson.save_to_json_file(json_file_path) : Save the class instance to a JSON file. pyobjson.base.PythonObjectJson.load_from_json_file(json_file_path) : Load the class instance from a pyobjson -formatted JSON file. Please reference the documentation at https://pyobjson.wrencode.dev for more detailed usage. JSON Example \u00b6 from pyobjson.base import PythonObjectJson class MyOtherClass ( PythonObjectJson ): def __init__ ( self ): super () . __init__ () self . message = \"Hello, World!\" class MyClass ( PythonObjectJson ): def __init__ ( self ): super () . __init__ () self . my_other_classes = [ MyOtherClass ()] my_class = MyClass () print ( my_class . to_json_str ()) JSON Example Output \u00b6 { \"__main__.myclass\" : { \"collection:list.my_other_classes\" : [ { \"__main__.myotherclass\" : { \"message\" : \"Hello, World!\" } } ] } } The above example shows how pyobjson can be used to serialize arbitrary custom Python classes into JSON. Additionally, the above JSON example output JSON can be used to recreate an equivalent class instance by loading the JSON into a custom Python class instance. Saving and Loading \u00b6 The pyobjson.base.PythonObjectJson parent class also provides built-in methods to save/load arbitrary custom Python classes to/from JSON in several ways. JSON Files \u00b6 JSON files (using only Python built-in libraries) : Use the PythonObjectJson.save_to_json_file(json_file_path) and PythonObjectJson.load_from_json_file(json_file_path) methods to save/load your custom Python subclasses to JSON files. JSON File Example \u00b6 from pathlib import Path from dotenv import load_dotenv from pyobjson.base import PythonObjectJson root_dir = Path ( __file__ ) . parent load_dotenv ( root_dir / \".env\" ) class CustomClassToJsonFile ( PythonObjectJson ): def __init__ ( self , message : str ): super () . __init__ () self . message = message custom_class_to_json_file = CustomClassToJsonFile ( \"Hello, World!\" ) output_dir = root_dir / \"output\" if not output_dir . is_dir (): output_dir . mkdir ( parents = True , exist_ok = True ) custom_class_to_json_file . save_to_json_file ( output_dir / \"custom_class_to_json_file.json\" ) custom_class_to_json_file . load_from_json_file ( output_dir / \"custom_class_to_json_file.json\" ) JSON File Output \u00b6 { \"__main__.customclasstojsonfile\" : { \"message\" : \"Hello, World!\" } } MongoDB \u00b6 MongoDB (using pymongo ) : The pyobjson library includes a class called pyobjson.dao.PythonObjectJsonToMongo , which can be used as a superclass for any custom class you wish to be able to easily serialized/deserialize to/from MongoDB. Use the PythonObjectJsonToMongo.save_to_mongo(mongo_collection) and PythonObjectJsonToMongo.load_from_mongo(mongo_collection, document_id) methods to save/load your custom Python subclasses to MongoDB. MongoDB Example \u00b6 import os from pathlib import Path from dotenv import load_dotenv from pyobjson.dao.mongo.base import PythonObjectJsonToMongo load_dotenv ( Path ( __file__ ) . parent / \".env\" ) class CustomClassToMongo ( PythonObjectJsonToMongo ): def __init__ ( self , mongo_host : str , mongo_port : int , mongo_database : str , mongo_user : str , mongo_password : str ): super () . __init__ ( mongo_host , mongo_port , mongo_database , mongo_user , mongo_password ) self . message = \"Hello, World!\" custom_class_to_mongo = CustomClassToMongo ( mongo_host = os . environ . get ( \"MONGO_HOST\" ), mongo_port = int ( os . environ . get ( \"MONGO_PORT\" )), mongo_database = os . environ . get ( \"MONGO_DATABASE\" ), mongo_user = os . environ . get ( \"MONGO_ADMIN_USER\" ), mongo_password = os . environ . get ( \"MONGO_ADMIN_PASS\" ), ) saved_mongo_document_id = custom_class_to_mongo . save_to_mongo ( os . environ . get ( \"MONGO_COLLECTION\" )) custom_class_to_mongo . load_from_mongo ( os . environ . get ( \"MONGO_COLLECTION\" ), saved_mongo_document_id ) MongoDB Output \u00b6 print(custom_class_to_mongo) : { \"__main__.customclasstomongo\" : { \"message\" : \"Hello, World!\" } } print(repr(custom_class_to_mongo)) : __main__.CustomClassToMongo ( mongo_host = localhost,mongo_port = 27017 ,mongo_database = pyobjson,mongo_user = <mongodb_user>,mongo_password = <mongodb_password> )","title":"pyobjson - Python Object JSON Tool"},{"location":"#pyobjson-python-object-json-tool","text":"Utility library for serializing/deserializing custom Python objects to/from JSON. Do you like the Python Object JSON Tool? Star the repository on GitHub and please consider helping support its ongoing development: READ THE DOCS HERE! Detailed documentation can be found at https://pyobjson.wrencode.dev .","title":"pyobjson - Python Object JSON Tool"},{"location":"#table-of-contents","text":"About Installation Dependencies Toolchain Usage JSON Example JSON Example Output Saving and Loading JSON Files JSON File Example JSON File Output MongoDB MongoDB Example MongoDB Output","title":"Table of Contents"},{"location":"#about","text":"The Python Object JSON Tool is a utility library for serializing/deserializing custom Python objects to/from JSON by using pyobjson classes as superclasses/parent classes to your custom Python classes.","title":"About"},{"location":"#installation","text":"You can install with pip by running: pip install pyobjson Note : If you wish to use pyobjson to serialize/deserialize custom Python objects to/from MongoDB, then you have to install with the optional dependencies: pip install pyobjson [ mongo ]","title":"Installation"},{"location":"#dependencies","text":"The base Python Object JSON Tool does not have any third-party dependencies to run the code. It has several development dependencies, which can be seen in the package pyproject.toml . If you wish to use pyobjson to serialize/deserialize custom Python objects to/from MongoDB, then there is an additional dependency on the PyMongo package.","title":"Dependencies"},{"location":"#toolchain","text":"The below tools and resources are used as part of pyobjson: uv - package management ruff - code linting bandit - code security make - Makefile build automation MkDocs - package documentation python-dotenv - programmatic access to environment variables defined in a .env file pytest - code testing framework GitHub Actions - CI/CD act - GitHub Actions testing","title":"Toolchain"},{"location":"#usage","text":"The pyobjson package is designed to be used as a base class/parent class/superclass to your own custom Python classes in order to provide built-in, convenient serialization/deserialization functionality. Child classes/subclasses of pyobjson.base.PythonObjectJson will automatically have the following methods: pyobjson.base.PythonObjectJson.serialize() : Create a serializable dictionary from the class instance. pyobjson.base.PythonObjectJson.to_json_str() : Serialize the class instance to a JSON string. pyobjson.base.PythonObjectJson.from_json_str(json_str) : Load the class instance from a pyobjson -formatted JSON string. pyobjson.base.PythonObjectJson.save_to_json_file(json_file_path) : Save the class instance to a JSON file. pyobjson.base.PythonObjectJson.load_from_json_file(json_file_path) : Load the class instance from a pyobjson -formatted JSON file. Please reference the documentation at https://pyobjson.wrencode.dev for more detailed usage.","title":"Usage"},{"location":"#json-example","text":"from pyobjson.base import PythonObjectJson class MyOtherClass ( PythonObjectJson ): def __init__ ( self ): super () . __init__ () self . message = \"Hello, World!\" class MyClass ( PythonObjectJson ): def __init__ ( self ): super () . __init__ () self . my_other_classes = [ MyOtherClass ()] my_class = MyClass () print ( my_class . to_json_str ())","title":"JSON Example"},{"location":"#json-example-output","text":"{ \"__main__.myclass\" : { \"collection:list.my_other_classes\" : [ { \"__main__.myotherclass\" : { \"message\" : \"Hello, World!\" } } ] } } The above example shows how pyobjson can be used to serialize arbitrary custom Python classes into JSON. Additionally, the above JSON example output JSON can be used to recreate an equivalent class instance by loading the JSON into a custom Python class instance.","title":"JSON Example Output"},{"location":"#saving-and-loading","text":"The pyobjson.base.PythonObjectJson parent class also provides built-in methods to save/load arbitrary custom Python classes to/from JSON in several ways.","title":"Saving and Loading"},{"location":"#json-files","text":"JSON files (using only Python built-in libraries) : Use the PythonObjectJson.save_to_json_file(json_file_path) and PythonObjectJson.load_from_json_file(json_file_path) methods to save/load your custom Python subclasses to JSON files.","title":"JSON Files"},{"location":"#json-file-example","text":"from pathlib import Path from dotenv import load_dotenv from pyobjson.base import PythonObjectJson root_dir = Path ( __file__ ) . parent load_dotenv ( root_dir / \".env\" ) class CustomClassToJsonFile ( PythonObjectJson ): def __init__ ( self , message : str ): super () . __init__ () self . message = message custom_class_to_json_file = CustomClassToJsonFile ( \"Hello, World!\" ) output_dir = root_dir / \"output\" if not output_dir . is_dir (): output_dir . mkdir ( parents = True , exist_ok = True ) custom_class_to_json_file . save_to_json_file ( output_dir / \"custom_class_to_json_file.json\" ) custom_class_to_json_file . load_from_json_file ( output_dir / \"custom_class_to_json_file.json\" )","title":"JSON File Example"},{"location":"#json-file-output","text":"{ \"__main__.customclasstojsonfile\" : { \"message\" : \"Hello, World!\" } }","title":"JSON File Output"},{"location":"#mongodb","text":"MongoDB (using pymongo ) : The pyobjson library includes a class called pyobjson.dao.PythonObjectJsonToMongo , which can be used as a superclass for any custom class you wish to be able to easily serialized/deserialize to/from MongoDB. Use the PythonObjectJsonToMongo.save_to_mongo(mongo_collection) and PythonObjectJsonToMongo.load_from_mongo(mongo_collection, document_id) methods to save/load your custom Python subclasses to MongoDB.","title":"MongoDB"},{"location":"#mongodb-example","text":"import os from pathlib import Path from dotenv import load_dotenv from pyobjson.dao.mongo.base import PythonObjectJsonToMongo load_dotenv ( Path ( __file__ ) . parent / \".env\" ) class CustomClassToMongo ( PythonObjectJsonToMongo ): def __init__ ( self , mongo_host : str , mongo_port : int , mongo_database : str , mongo_user : str , mongo_password : str ): super () . __init__ ( mongo_host , mongo_port , mongo_database , mongo_user , mongo_password ) self . message = \"Hello, World!\" custom_class_to_mongo = CustomClassToMongo ( mongo_host = os . environ . get ( \"MONGO_HOST\" ), mongo_port = int ( os . environ . get ( \"MONGO_PORT\" )), mongo_database = os . environ . get ( \"MONGO_DATABASE\" ), mongo_user = os . environ . get ( \"MONGO_ADMIN_USER\" ), mongo_password = os . environ . get ( \"MONGO_ADMIN_PASS\" ), ) saved_mongo_document_id = custom_class_to_mongo . save_to_mongo ( os . environ . get ( \"MONGO_COLLECTION\" )) custom_class_to_mongo . load_from_mongo ( os . environ . get ( \"MONGO_COLLECTION\" ), saved_mongo_document_id )","title":"MongoDB Example"},{"location":"#mongodb-output","text":"print(custom_class_to_mongo) : { \"__main__.customclasstomongo\" : { \"message\" : \"Hello, World!\" } } print(repr(custom_class_to_mongo)) : __main__.CustomClassToMongo ( mongo_host = localhost,mongo_port = 27017 ,mongo_database = pyobjson,mongo_user = <mongodb_user>,mongo_password = <mongodb_password> )","title":"MongoDB Output"},{"location":"base/","text":"pyobjson - Python Object JSON Tool \u00b6 Python Object JSON Tool pyobjson.base module. Attributes: __author__ ( str ) \u2013 Python package template author. __email__ ( str ) \u2013 Python package template author email. Classes: Name Description PythonObjectJson Base Python Object with JSON serialization and deserialization compatibility. PythonObjectJson \u00b6 Bases: object Base Python Object with JSON serialization and deserialization compatibility. Methods: Name Description __init__ Instantiate the PythonObjectJson class with all keyword arguments. serialize Create a serializable dictionary from the class instance. deserialize Load data to a class instance from a serializable dictionary. to_json_str Serialize the class instance to a JSON string. from_json_str Load a class instance deserialized from a JSON string to the current class instance. save_to_json_file Save the class instance to a JSON file. load_from_json_file Load the class instance from a JSON file. Source code in src/pyobjson/base.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 class PythonObjectJson ( object ): \"\"\"Base Python Object with JSON serialization and deserialization compatibility.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Instantiate the PythonObjectJson class with all keyword arguments. Args: kwargs (dict): Key/value pairs to be passed to the PythonObjectJson class. \"\"\" vars ( self ) . update ( kwargs ) def __str__ ( self ): return self . to_json_str () def __repr__ ( self ): return ( f \" { derive_custom_object_key ( self . __class__ , as_lower = False ) } \" f \"( { ',' . join ([ f ' { k } = { v } ' for k , v in vars ( self ) . items () if k in getfullargspec ( self . __init__ ) . args ]) } )\" ) def __eq__ ( self , other ): return type ( self ) is type ( other ) and vars ( self ) == vars ( other ) def _base_subclasses ( self ) -> Dict [ str , Type ]: \"\"\"Create a dictionary with lowercase keys derived from custom class names in camelcase mapped to their respective custom classes. Returns: dict[str, Type]: Dictionary with lowercase strings of all subclasses of PythonObjectJson as keys and subclasses as values. \"\"\" # retrieve all class subclasses (and their nested subclasses) after base class return { derive_custom_object_key ( cls ): cls for cls in get_nested_subclasses ( self . __class__ . __mro__ [ - 2 ])} def serialize ( self ) -> Dict [ str , Any ]: \"\"\"Create a serializable dictionary from the class instance. Returns: dict[str, Any]: Serializable dictionary representing the class instance. \"\"\" return serialize ( self , list ( self . _base_subclasses () . values ()), []) def deserialize ( self , serializable_dict : Dict [ str , Any ]) -> Any : \"\"\"Load data to a class instance from a serializable dictionary. Args: serializable_dict (dict[str, Any]): Serializable dictionary representing the class instance. Returns: Any: Class instance deserialized from data dictionary. \"\"\" return deserialize ( serializable_dict , self . _base_subclasses (), base_class_instance = self ) def to_json_str ( self ) -> str : \"\"\"Serialize the class instance to a JSON string. Returns: str: JSON string derived from the serializable version of the class instance. \"\"\" return json . dumps ( self . serialize (), ensure_ascii = False , indent = 2 ) def from_json_str ( self , json_str : str ) -> None : \"\"\"Load a class instance deserialized from a JSON string to the current class instance. Args: json_str (str): JSON string to be deserialized into the class instance. Returns: None \"\"\" self . deserialize ( json . loads ( json_str )) def save_to_json_file ( self , json_file_path : Path ) -> None : \"\"\"Save the class instance to a JSON file. Args: json_file_path (Path): Target JSON file path to which the class instance will be saved. Returns: None \"\"\" if not json_file_path . exists (): json_file_path . parent . mkdir ( parents = True , exist_ok = True ) with open ( json_file_path , \"w\" , encoding = \"utf-8\" ) as json_file_out : # TODO: fix incorrect file input type warning for json.dump from PyCharm bug https://youtrack.jetbrains.com/issue/PY-73050/openfile.txt-r-return-type-should-be-inferred-as-TextIOWrapper-instead-of-TextIO # noinspection PyTypeChecker json . dump ( self . serialize (), json_file_out , ensure_ascii = False , indent = 2 ) def load_from_json_file ( self , json_file_path : Path ) -> None : \"\"\"Load the class instance from a JSON file. Args: json_file_path (Path): Target JSON file path from which the class instance will be loaded. Returns: None \"\"\" if not json_file_path . exists (): raise FileNotFoundError ( f \"File { json_file_path } does not exist. Unable to load saved data.\" ) with open ( json_file_path , \"r\" , encoding = \"utf-8\" ) as json_file_in : self . deserialize ( json . load ( json_file_in )) __init__ \u00b6 __init__ ( ** kwargs ) Instantiate the PythonObjectJson class with all keyword arguments. Parameters: kwargs ( dict , default: {} ) \u2013 Key/value pairs to be passed to the PythonObjectJson class. Source code in src/pyobjson/base.py 24 25 26 27 28 29 30 31 def __init__ ( self , ** kwargs ): \"\"\"Instantiate the PythonObjectJson class with all keyword arguments. Args: kwargs (dict): Key/value pairs to be passed to the PythonObjectJson class. \"\"\" vars ( self ) . update ( kwargs ) serialize \u00b6 serialize () Create a serializable dictionary from the class instance. Returns: Dict [ str , Any ] \u2013 dict[str, Any]: Serializable dictionary representing the class instance. Source code in src/pyobjson/base.py 57 58 59 60 61 62 63 64 def serialize ( self ) -> Dict [ str , Any ]: \"\"\"Create a serializable dictionary from the class instance. Returns: dict[str, Any]: Serializable dictionary representing the class instance. \"\"\" return serialize ( self , list ( self . _base_subclasses () . values ()), []) deserialize \u00b6 deserialize ( serializable_dict ) Load data to a class instance from a serializable dictionary. Parameters: serializable_dict ( dict [ str , Any ] ) \u2013 Serializable dictionary representing the class instance. Returns: Any ( Any ) \u2013 Class instance deserialized from data dictionary. Source code in src/pyobjson/base.py 66 67 68 69 70 71 72 73 74 75 76 def deserialize ( self , serializable_dict : Dict [ str , Any ]) -> Any : \"\"\"Load data to a class instance from a serializable dictionary. Args: serializable_dict (dict[str, Any]): Serializable dictionary representing the class instance. Returns: Any: Class instance deserialized from data dictionary. \"\"\" return deserialize ( serializable_dict , self . _base_subclasses (), base_class_instance = self ) to_json_str \u00b6 to_json_str () Serialize the class instance to a JSON string. Returns: str ( str ) \u2013 JSON string derived from the serializable version of the class instance. Source code in src/pyobjson/base.py 78 79 80 81 82 83 84 85 def to_json_str ( self ) -> str : \"\"\"Serialize the class instance to a JSON string. Returns: str: JSON string derived from the serializable version of the class instance. \"\"\" return json . dumps ( self . serialize (), ensure_ascii = False , indent = 2 ) from_json_str \u00b6 from_json_str ( json_str ) Load a class instance deserialized from a JSON string to the current class instance. Parameters: json_str ( str ) \u2013 JSON string to be deserialized into the class instance. Returns: None \u2013 None Source code in src/pyobjson/base.py 87 88 89 90 91 92 93 94 95 96 97 def from_json_str ( self , json_str : str ) -> None : \"\"\"Load a class instance deserialized from a JSON string to the current class instance. Args: json_str (str): JSON string to be deserialized into the class instance. Returns: None \"\"\" self . deserialize ( json . loads ( json_str )) save_to_json_file \u00b6 save_to_json_file ( json_file_path ) Save the class instance to a JSON file. Parameters: json_file_path ( Path ) \u2013 Target JSON file path to which the class instance will be saved. Returns: None \u2013 None Source code in src/pyobjson/base.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def save_to_json_file ( self , json_file_path : Path ) -> None : \"\"\"Save the class instance to a JSON file. Args: json_file_path (Path): Target JSON file path to which the class instance will be saved. Returns: None \"\"\" if not json_file_path . exists (): json_file_path . parent . mkdir ( parents = True , exist_ok = True ) with open ( json_file_path , \"w\" , encoding = \"utf-8\" ) as json_file_out : # TODO: fix incorrect file input type warning for json.dump from PyCharm bug https://youtrack.jetbrains.com/issue/PY-73050/openfile.txt-r-return-type-should-be-inferred-as-TextIOWrapper-instead-of-TextIO # noinspection PyTypeChecker json . dump ( self . serialize (), json_file_out , ensure_ascii = False , indent = 2 ) load_from_json_file \u00b6 load_from_json_file ( json_file_path ) Load the class instance from a JSON file. Parameters: json_file_path ( Path ) \u2013 Target JSON file path from which the class instance will be loaded. Returns: None \u2013 None Source code in src/pyobjson/base.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def load_from_json_file ( self , json_file_path : Path ) -> None : \"\"\"Load the class instance from a JSON file. Args: json_file_path (Path): Target JSON file path from which the class instance will be loaded. Returns: None \"\"\" if not json_file_path . exists (): raise FileNotFoundError ( f \"File { json_file_path } does not exist. Unable to load saved data.\" ) with open ( json_file_path , \"r\" , encoding = \"utf-8\" ) as json_file_in : self . deserialize ( json . load ( json_file_in ))","title":"pyobjson.base"},{"location":"base/#pyobjson-python-object-json-tool","text":"Python Object JSON Tool pyobjson.base module. Attributes: __author__ ( str ) \u2013 Python package template author. __email__ ( str ) \u2013 Python package template author email. Classes: Name Description PythonObjectJson Base Python Object with JSON serialization and deserialization compatibility.","title":"pyobjson - Python Object JSON Tool"},{"location":"base/#src.pyobjson.base.PythonObjectJson","text":"Bases: object Base Python Object with JSON serialization and deserialization compatibility. Methods: Name Description __init__ Instantiate the PythonObjectJson class with all keyword arguments. serialize Create a serializable dictionary from the class instance. deserialize Load data to a class instance from a serializable dictionary. to_json_str Serialize the class instance to a JSON string. from_json_str Load a class instance deserialized from a JSON string to the current class instance. save_to_json_file Save the class instance to a JSON file. load_from_json_file Load the class instance from a JSON file. Source code in src/pyobjson/base.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 class PythonObjectJson ( object ): \"\"\"Base Python Object with JSON serialization and deserialization compatibility.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Instantiate the PythonObjectJson class with all keyword arguments. Args: kwargs (dict): Key/value pairs to be passed to the PythonObjectJson class. \"\"\" vars ( self ) . update ( kwargs ) def __str__ ( self ): return self . to_json_str () def __repr__ ( self ): return ( f \" { derive_custom_object_key ( self . __class__ , as_lower = False ) } \" f \"( { ',' . join ([ f ' { k } = { v } ' for k , v in vars ( self ) . items () if k in getfullargspec ( self . __init__ ) . args ]) } )\" ) def __eq__ ( self , other ): return type ( self ) is type ( other ) and vars ( self ) == vars ( other ) def _base_subclasses ( self ) -> Dict [ str , Type ]: \"\"\"Create a dictionary with lowercase keys derived from custom class names in camelcase mapped to their respective custom classes. Returns: dict[str, Type]: Dictionary with lowercase strings of all subclasses of PythonObjectJson as keys and subclasses as values. \"\"\" # retrieve all class subclasses (and their nested subclasses) after base class return { derive_custom_object_key ( cls ): cls for cls in get_nested_subclasses ( self . __class__ . __mro__ [ - 2 ])} def serialize ( self ) -> Dict [ str , Any ]: \"\"\"Create a serializable dictionary from the class instance. Returns: dict[str, Any]: Serializable dictionary representing the class instance. \"\"\" return serialize ( self , list ( self . _base_subclasses () . values ()), []) def deserialize ( self , serializable_dict : Dict [ str , Any ]) -> Any : \"\"\"Load data to a class instance from a serializable dictionary. Args: serializable_dict (dict[str, Any]): Serializable dictionary representing the class instance. Returns: Any: Class instance deserialized from data dictionary. \"\"\" return deserialize ( serializable_dict , self . _base_subclasses (), base_class_instance = self ) def to_json_str ( self ) -> str : \"\"\"Serialize the class instance to a JSON string. Returns: str: JSON string derived from the serializable version of the class instance. \"\"\" return json . dumps ( self . serialize (), ensure_ascii = False , indent = 2 ) def from_json_str ( self , json_str : str ) -> None : \"\"\"Load a class instance deserialized from a JSON string to the current class instance. Args: json_str (str): JSON string to be deserialized into the class instance. Returns: None \"\"\" self . deserialize ( json . loads ( json_str )) def save_to_json_file ( self , json_file_path : Path ) -> None : \"\"\"Save the class instance to a JSON file. Args: json_file_path (Path): Target JSON file path to which the class instance will be saved. Returns: None \"\"\" if not json_file_path . exists (): json_file_path . parent . mkdir ( parents = True , exist_ok = True ) with open ( json_file_path , \"w\" , encoding = \"utf-8\" ) as json_file_out : # TODO: fix incorrect file input type warning for json.dump from PyCharm bug https://youtrack.jetbrains.com/issue/PY-73050/openfile.txt-r-return-type-should-be-inferred-as-TextIOWrapper-instead-of-TextIO # noinspection PyTypeChecker json . dump ( self . serialize (), json_file_out , ensure_ascii = False , indent = 2 ) def load_from_json_file ( self , json_file_path : Path ) -> None : \"\"\"Load the class instance from a JSON file. Args: json_file_path (Path): Target JSON file path from which the class instance will be loaded. Returns: None \"\"\" if not json_file_path . exists (): raise FileNotFoundError ( f \"File { json_file_path } does not exist. Unable to load saved data.\" ) with open ( json_file_path , \"r\" , encoding = \"utf-8\" ) as json_file_in : self . deserialize ( json . load ( json_file_in ))","title":"PythonObjectJson"},{"location":"base/#src.pyobjson.base.PythonObjectJson.__init__","text":"__init__ ( ** kwargs ) Instantiate the PythonObjectJson class with all keyword arguments. Parameters: kwargs ( dict , default: {} ) \u2013 Key/value pairs to be passed to the PythonObjectJson class. Source code in src/pyobjson/base.py 24 25 26 27 28 29 30 31 def __init__ ( self , ** kwargs ): \"\"\"Instantiate the PythonObjectJson class with all keyword arguments. Args: kwargs (dict): Key/value pairs to be passed to the PythonObjectJson class. \"\"\" vars ( self ) . update ( kwargs )","title":"__init__"},{"location":"base/#src.pyobjson.base.PythonObjectJson.serialize","text":"serialize () Create a serializable dictionary from the class instance. Returns: Dict [ str , Any ] \u2013 dict[str, Any]: Serializable dictionary representing the class instance. Source code in src/pyobjson/base.py 57 58 59 60 61 62 63 64 def serialize ( self ) -> Dict [ str , Any ]: \"\"\"Create a serializable dictionary from the class instance. Returns: dict[str, Any]: Serializable dictionary representing the class instance. \"\"\" return serialize ( self , list ( self . _base_subclasses () . values ()), [])","title":"serialize"},{"location":"base/#src.pyobjson.base.PythonObjectJson.deserialize","text":"deserialize ( serializable_dict ) Load data to a class instance from a serializable dictionary. Parameters: serializable_dict ( dict [ str , Any ] ) \u2013 Serializable dictionary representing the class instance. Returns: Any ( Any ) \u2013 Class instance deserialized from data dictionary. Source code in src/pyobjson/base.py 66 67 68 69 70 71 72 73 74 75 76 def deserialize ( self , serializable_dict : Dict [ str , Any ]) -> Any : \"\"\"Load data to a class instance from a serializable dictionary. Args: serializable_dict (dict[str, Any]): Serializable dictionary representing the class instance. Returns: Any: Class instance deserialized from data dictionary. \"\"\" return deserialize ( serializable_dict , self . _base_subclasses (), base_class_instance = self )","title":"deserialize"},{"location":"base/#src.pyobjson.base.PythonObjectJson.to_json_str","text":"to_json_str () Serialize the class instance to a JSON string. Returns: str ( str ) \u2013 JSON string derived from the serializable version of the class instance. Source code in src/pyobjson/base.py 78 79 80 81 82 83 84 85 def to_json_str ( self ) -> str : \"\"\"Serialize the class instance to a JSON string. Returns: str: JSON string derived from the serializable version of the class instance. \"\"\" return json . dumps ( self . serialize (), ensure_ascii = False , indent = 2 )","title":"to_json_str"},{"location":"base/#src.pyobjson.base.PythonObjectJson.from_json_str","text":"from_json_str ( json_str ) Load a class instance deserialized from a JSON string to the current class instance. Parameters: json_str ( str ) \u2013 JSON string to be deserialized into the class instance. Returns: None \u2013 None Source code in src/pyobjson/base.py 87 88 89 90 91 92 93 94 95 96 97 def from_json_str ( self , json_str : str ) -> None : \"\"\"Load a class instance deserialized from a JSON string to the current class instance. Args: json_str (str): JSON string to be deserialized into the class instance. Returns: None \"\"\" self . deserialize ( json . loads ( json_str ))","title":"from_json_str"},{"location":"base/#src.pyobjson.base.PythonObjectJson.save_to_json_file","text":"save_to_json_file ( json_file_path ) Save the class instance to a JSON file. Parameters: json_file_path ( Path ) \u2013 Target JSON file path to which the class instance will be saved. Returns: None \u2013 None Source code in src/pyobjson/base.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def save_to_json_file ( self , json_file_path : Path ) -> None : \"\"\"Save the class instance to a JSON file. Args: json_file_path (Path): Target JSON file path to which the class instance will be saved. Returns: None \"\"\" if not json_file_path . exists (): json_file_path . parent . mkdir ( parents = True , exist_ok = True ) with open ( json_file_path , \"w\" , encoding = \"utf-8\" ) as json_file_out : # TODO: fix incorrect file input type warning for json.dump from PyCharm bug https://youtrack.jetbrains.com/issue/PY-73050/openfile.txt-r-return-type-should-be-inferred-as-TextIOWrapper-instead-of-TextIO # noinspection PyTypeChecker json . dump ( self . serialize (), json_file_out , ensure_ascii = False , indent = 2 )","title":"save_to_json_file"},{"location":"base/#src.pyobjson.base.PythonObjectJson.load_from_json_file","text":"load_from_json_file ( json_file_path ) Load the class instance from a JSON file. Parameters: json_file_path ( Path ) \u2013 Target JSON file path from which the class instance will be loaded. Returns: None \u2013 None Source code in src/pyobjson/base.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def load_from_json_file ( self , json_file_path : Path ) -> None : \"\"\"Load the class instance from a JSON file. Args: json_file_path (Path): Target JSON file path from which the class instance will be loaded. Returns: None \"\"\" if not json_file_path . exists (): raise FileNotFoundError ( f \"File { json_file_path } does not exist. Unable to load saved data.\" ) with open ( json_file_path , \"r\" , encoding = \"utf-8\" ) as json_file_in : self . deserialize ( json . load ( json_file_in ))","title":"load_from_json_file"},{"location":"data/","text":"Data Tools \u00b6 Python Object JSON Tool pyobjson.json module. Attributes: __author__ ( str ) \u2013 Python package template author. __email__ ( str ) \u2013 Python package template author email. Functions: Name Description unpack_custom_class_vars Recursive function to un-type custom class type objects for serialization. extract_typed_key_value_pairs Function to extract both keys and Python object types from specially formatted dictionary keys and make serialize Recursive function to serialize custom Python objects into nested dictionaries for conversion to JSON. deserialize Recursive function to deserialize JSON into typed data structures for conversion to custom Python objects. unpack_custom_class_vars \u00b6 unpack_custom_class_vars ( custom_class_instance , pyobjson_base_custom_subclasses , excluded_attributes , ) Recursive function to un-type custom class type objects for serialization. Parameters: custom_class_instance ( Any ) \u2013 Custom Python class instance to be serialized. pyobjson_base_custom_subclasses ( list [ Type ] ) \u2013 List of custom Python class subclasses. excluded_attributes ( list [ str ] ) \u2013 List of attributes to exclude from serialization. Supports substring matching exclusions. Returns: Dict [ str , Any ] \u2013 dict[str, Any]: Dictionary that extracts serializable data from custom objects. Source code in src/pyobjson/data.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def unpack_custom_class_vars ( custom_class_instance : Any , pyobjson_base_custom_subclasses : List [ Type ], excluded_attributes : List [ str ] ) -> Dict [ str , Any ]: \"\"\"Recursive function to un-type custom class type objects for serialization. Args: custom_class_instance (Any): Custom Python class instance to be serialized. pyobjson_base_custom_subclasses (list[Type]): List of custom Python class subclasses. excluded_attributes (list[str]): List of attributes to exclude from serialization. Supports substring matching exclusions. Returns: dict[str, Any]: Dictionary that extracts serializable data from custom objects. \"\"\" attributes = dict ( vars ( custom_class_instance ) . items ()) # filter out excluded attributes if excluded_attributes : excluded_att_keys = set () for att in attributes . keys (): for excl_att in excluded_attributes : if att . startswith ( excl_att ): excluded_att_keys . add ( att ) attributes = { att : val for att , val in attributes . items () if att not in excluded_att_keys } unpacked = {} for k , v in attributes . items (): unpacked [ k ] = ( { derive_custom_object_key ( v ): unpack_custom_class_vars ( v , pyobjson_base_custom_subclasses , excluded_attributes ) } if type ( v ) in pyobjson_base_custom_subclasses else v ) return unpacked extract_typed_key_value_pairs \u00b6 extract_typed_key_value_pairs ( json_dict , pyobjson_base_custom_subclasses_by_key ) Function to extract both keys and Python object types from specially formatted dictionary keys and make their respective values into Python objects of those types. Parameters: json_dict ( Dict [ str , Any ] ) \u2013 JSON dictionary that may contain keys in the format type.key_name (e.g. path.root_directory) with corresponding string values representing Python objects of that type. pyobjson_base_custom_subclasses_by_key ( dict [ str , Type ] ) \u2013 Dictionary with lowercase strings of all subclasses of PythonObjectJson as keys and subclasses as values. Returns: Dict [ str , Any ] \u2013 dict[str, Any]: Dictionary with both keys and Python object values derived from specially formatted JSON dictionary keys. Source code in src/pyobjson/data.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def extract_typed_key_value_pairs ( json_dict : Dict [ str , Any ], pyobjson_base_custom_subclasses_by_key : Dict [ str , Type ] ) -> Dict [ str , Any ]: \"\"\"Function to extract both keys and Python object types from specially formatted dictionary keys and make their respective values into Python objects of those types. Args: json_dict (Dict[str, Any]): JSON dictionary that may contain keys in the format type.key_name (e.g. path.root_directory) with corresponding string values representing Python objects of that type. pyobjson_base_custom_subclasses_by_key (dict[str, Type]): Dictionary with lowercase strings of all subclasses of PythonObjectJson as keys and subclasses as values. Returns: dict[str, Any]: Dictionary with both keys and Python object values derived from specially formatted JSON dictionary keys. \"\"\" derived_key_value_pairs = {} for key , value in json_dict . items (): # check if value is a custom object that will be deserialized as its respective object type or if key is # formatted with a single \".\" to indicate a Python builtin value type if key not in pyobjson_base_custom_subclasses_by_key . keys () and key . count ( \".\" ) == 1 : # check if key is formatted with a single \".\" to indicate a value type type_name , key = key . split ( \".\" ) type_category = None if type_name . count ( \":\" ) == 1 : type_category , type_name = type_name . split ( \":\" ) if type_category == \"collection\" : if type_name == \"dict\" : # do nothing because JSON supports dictionaries pass elif type_name == \"list\" : # do nothing because JSON supports lists pass elif type_name == \"set\" : value = set ( value ) elif type_name == \"tuple\" : value = tuple ( value ) elif type_name == \"bytes\" or type_name == \"bytearray\" : value = b64decode ( value ) elif type_name == \"path\" : # handle posix paths value = Path ( value ) elif type_name == \"callable\" : # handle callables (functions, methods, etc.) # extract the callable components from a value with format module.callable::arg1:type1,arg2:type2 callable_path , callable_args = value . split ( \"::\" , 1 ) # extract the callable module and name module , callable_name = callable_path . rsplit ( \".\" , 1 ) # use the callable module and name to import the callable itself and set it to the value value = getattr ( import_module ( module ), callable_name ) elif type_name == \"datetime\" : # handle datetime objects value = datetime . fromisoformat ( value ) else : raise ValueError ( f \"JSON data ( { key } : { value } ) is not compatible with pyobjson.\" ) derived_key_value_pairs [ key ] = value return derived_key_value_pairs serialize \u00b6 serialize ( obj , pyobjson_base_custom_subclasses , excluded_attributes , ) Recursive function to serialize custom Python objects into nested dictionaries for conversion to JSON. Parameters: obj ( Any ) \u2013 Python object to serialize. pyobjson_base_custom_subclasses ( list [ Type ] ) \u2013 List of custom Python class subclasses. excluded_attributes ( list [ str ] ) \u2013 List of attributes to exclude from serialization. Supports substring matching exclusions. Returns: Any \u2013 dict[str, Any]: Serializable dictionary. Source code in src/pyobjson/data.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 def serialize ( obj : Any , pyobjson_base_custom_subclasses : List [ Type ], excluded_attributes : List [ str ]) -> Any : \"\"\"Recursive function to serialize custom Python objects into nested dictionaries for conversion to JSON. Args: obj (Any): Python object to serialize. pyobjson_base_custom_subclasses (list[Type]): List of custom Python class subclasses. excluded_attributes (list[str]): List of attributes to exclude from serialization. Supports substring matching exclusions. Returns: dict[str, Any]: Serializable dictionary. \"\"\" if type ( obj ) in pyobjson_base_custom_subclasses : serializable_obj = {} attributes = { k : v for k , v in unpack_custom_class_vars ( obj , pyobjson_base_custom_subclasses , excluded_attributes ) . items () } for att , val in attributes . items (): if isinstance ( val , dict ): # noinspection PyUnboundLocalVariable if ( len ( val ) == 1 and ( single_key := next ( iter ( val . keys ()))) and single_key in [ derive_custom_object_key ( subclass ) for subclass in pyobjson_base_custom_subclasses ] ): # do nothing because attribute key for custom Python object is already formatted correctly by # unpack custom_class_vars() pass else : att = f \"collection:dict. { att } \" elif isinstance ( val , ( list , set , tuple , bytes , bytearray )): att = f \"collection: { derive_custom_object_key ( val . __class__ ) } . { att } \" elif isinstance ( val , Path ): att = f \"path. { att } \" elif isinstance ( val , Callable ): att = f \"callable. { att } \" elif isinstance ( val , datetime ): att = f \"datetime. { att } \" else : try : json . dumps ( val ) except TypeError as e : if str ( e ) == f \"Object of type { type ( val ) . __name__ } is not JSON serializable\" : att = f \"repr: { derive_custom_object_key ( val . __class__ ) } \" else : att = f \"UNSERIALIZABLE. { derive_custom_object_key ( val . __class__ ) } \" serializable_obj [ att ] = serialize ( val , pyobjson_base_custom_subclasses , excluded_attributes ) return { derive_custom_object_key ( obj . __class__ ): serializable_obj } elif isinstance ( obj , dict ): return { k : serialize ( v , pyobjson_base_custom_subclasses , excluded_attributes ) for k , v in obj . items ()} elif isinstance ( obj , ( list , set , tuple )): return [ serialize ( v , pyobjson_base_custom_subclasses , excluded_attributes ) for v in obj ] elif isinstance ( obj , ( bytes , bytearray )): return b64encode ( obj ) . decode ( \"utf-8\" ) elif isinstance ( obj , Path ): return str ( obj ) elif isinstance ( obj , Callable ): return derive_custom_callable_value ( obj ) elif isinstance ( obj , datetime ): return obj . isoformat () else : try : json . dumps ( obj ) except TypeError as e : if str ( e ) == f \"Object of type { type ( obj ) . __name__ } is not JSON serializable\" : return repr ( obj ) else : return \"UNSERIALIZABLE\" return obj deserialize \u00b6 deserialize ( json_data , pyobjson_base_custom_subclasses_by_key , base_class_instance = None , extra_instance_atts = None , ) Recursive function to deserialize JSON into typed data structures for conversion to custom Python objects. Parameters: json_data ( Any ) \u2013 JSON data to be deserialized. pyobjson_base_custom_subclasses_by_key ( dict [ str , Type ] ) \u2013 Dictionary with lowercase strings of all subclasses of PythonObjectJson as keys and subclasses as values. base_class_instance ( Optional [ Any ] , default: None ) \u2013 Target class instance into which to deserialize JSON data. extra_instance_atts ( Optional [ Dict [ str , Any ]] , default: None ) \u2013 Dictionary with extra required class attributes for custom Python objects. Returns: obj ( Any ) \u2013 Object deserialized from JSON. Source code in src/pyobjson/data.py 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 def deserialize ( json_data : Any , pyobjson_base_custom_subclasses_by_key : Dict [ str , Type ], base_class_instance : Optional [ Any ] = None , extra_instance_atts : Optional [ Dict [ str , Any ]] = None , ) -> Any : \"\"\"Recursive function to deserialize JSON into typed data structures for conversion to custom Python objects. Args: json_data (Any): JSON data to be deserialized. pyobjson_base_custom_subclasses_by_key (dict[str, Type]): Dictionary with lowercase strings of all subclasses of PythonObjectJson as keys and subclasses as values. base_class_instance (Optional[Any]): Target class instance into which to deserialize JSON data. extra_instance_atts (Optional[Dict[str, Any]]): Dictionary with extra required class attributes for custom Python objects. Returns: obj (Any): Object deserialized from JSON. \"\"\" if not extra_instance_atts : extra_instance_atts = {} base_subclasses : Dict [ str , Type ] = pyobjson_base_custom_subclasses_by_key if isinstance ( json_data , list ): # recursively deserialize all elements if json_data is a list return [ deserialize ( item , base_subclasses , extra_instance_atts = extra_instance_atts ) for item in json_data ] elif isinstance ( json_data , dict ): # recursively deserialize all values if json_data is a dictionary # check if json_data is a dict with only one key that matches a custom subclass for object derivation # noinspection PyUnboundLocalVariable if len ( json_data ) == 1 and ( single_key := next ( iter ( json_data . keys ()))) and single_key in base_subclasses : # noinspection PyPep8Naming ClassObject = base_subclasses [ single_key ] # retrieve custom subclass class_args = getfullargspec ( ClassObject . __init__ ) . args [ 1 :] # get __init__ arguments for custom subclass class_instance_attributes : Dict [ str , Any ] = json_data [ single_key ] # get JSON to be deserialized if ClassObject == base_class_instance . __class__ : # avoid creating a new class instance if an existing base class instance has been provided class_instance = base_class_instance else : # extract original attribute names from pyobjson formatted attribute keys extracted_class_instance_atts = { att . split ( \".\" )[ - 1 ] for att in class_instance_attributes . keys ()} # check if any required instance attributes are missing from the deserialized data if missing_instances_atts := set ( class_args ) . difference ( extracted_class_instance_atts ): if set ( extra_instance_atts . keys ()) . issuperset ( missing_instances_atts ): class_instance_attributes . update ( extra_instance_atts ) else : logger . warning ( f \"Missing required instance attributes \" f '\" { missing_instances_atts . difference ( set ( extra_instance_atts . keys ())) } \" for custom ' f 'class \" { ClassObject . __name__ } \".' ) sys . exit ( 1 ) # create an instance of the custom subclass using the __init__ arguments class_instance = ClassObject ( ** { k : deserialize ( v , base_subclasses , extra_instance_atts = extra_instance_atts ) for k , v in extract_typed_key_value_pairs ( class_instance_attributes , base_subclasses ) . items () if k in class_args } ) # assign the remaining class attributes to the class instance # noinspection PyUnresolvedReferences vars ( class_instance ) . update ( { k : deserialize ( v , base_subclasses , extra_instance_atts = extra_instance_atts ) for k , v in extract_typed_key_value_pairs ( class_instance_attributes , base_subclasses ) . items () } ) return class_instance if not base_class_instance else None else : return { k : deserialize ( v , base_subclasses , extra_instance_atts = extra_instance_atts ) for k , v in extract_typed_key_value_pairs ( json_data , base_subclasses ) . items () } else : return json_data","title":"pyobjson.data"},{"location":"data/#data-tools","text":"Python Object JSON Tool pyobjson.json module. Attributes: __author__ ( str ) \u2013 Python package template author. __email__ ( str ) \u2013 Python package template author email. Functions: Name Description unpack_custom_class_vars Recursive function to un-type custom class type objects for serialization. extract_typed_key_value_pairs Function to extract both keys and Python object types from specially formatted dictionary keys and make serialize Recursive function to serialize custom Python objects into nested dictionaries for conversion to JSON. deserialize Recursive function to deserialize JSON into typed data structures for conversion to custom Python objects.","title":"Data Tools"},{"location":"data/#src.pyobjson.data.unpack_custom_class_vars","text":"unpack_custom_class_vars ( custom_class_instance , pyobjson_base_custom_subclasses , excluded_attributes , ) Recursive function to un-type custom class type objects for serialization. Parameters: custom_class_instance ( Any ) \u2013 Custom Python class instance to be serialized. pyobjson_base_custom_subclasses ( list [ Type ] ) \u2013 List of custom Python class subclasses. excluded_attributes ( list [ str ] ) \u2013 List of attributes to exclude from serialization. Supports substring matching exclusions. Returns: Dict [ str , Any ] \u2013 dict[str, Any]: Dictionary that extracts serializable data from custom objects. Source code in src/pyobjson/data.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def unpack_custom_class_vars ( custom_class_instance : Any , pyobjson_base_custom_subclasses : List [ Type ], excluded_attributes : List [ str ] ) -> Dict [ str , Any ]: \"\"\"Recursive function to un-type custom class type objects for serialization. Args: custom_class_instance (Any): Custom Python class instance to be serialized. pyobjson_base_custom_subclasses (list[Type]): List of custom Python class subclasses. excluded_attributes (list[str]): List of attributes to exclude from serialization. Supports substring matching exclusions. Returns: dict[str, Any]: Dictionary that extracts serializable data from custom objects. \"\"\" attributes = dict ( vars ( custom_class_instance ) . items ()) # filter out excluded attributes if excluded_attributes : excluded_att_keys = set () for att in attributes . keys (): for excl_att in excluded_attributes : if att . startswith ( excl_att ): excluded_att_keys . add ( att ) attributes = { att : val for att , val in attributes . items () if att not in excluded_att_keys } unpacked = {} for k , v in attributes . items (): unpacked [ k ] = ( { derive_custom_object_key ( v ): unpack_custom_class_vars ( v , pyobjson_base_custom_subclasses , excluded_attributes ) } if type ( v ) in pyobjson_base_custom_subclasses else v ) return unpacked","title":"unpack_custom_class_vars"},{"location":"data/#src.pyobjson.data.extract_typed_key_value_pairs","text":"extract_typed_key_value_pairs ( json_dict , pyobjson_base_custom_subclasses_by_key ) Function to extract both keys and Python object types from specially formatted dictionary keys and make their respective values into Python objects of those types. Parameters: json_dict ( Dict [ str , Any ] ) \u2013 JSON dictionary that may contain keys in the format type.key_name (e.g. path.root_directory) with corresponding string values representing Python objects of that type. pyobjson_base_custom_subclasses_by_key ( dict [ str , Type ] ) \u2013 Dictionary with lowercase strings of all subclasses of PythonObjectJson as keys and subclasses as values. Returns: Dict [ str , Any ] \u2013 dict[str, Any]: Dictionary with both keys and Python object values derived from specially formatted JSON dictionary keys. Source code in src/pyobjson/data.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def extract_typed_key_value_pairs ( json_dict : Dict [ str , Any ], pyobjson_base_custom_subclasses_by_key : Dict [ str , Type ] ) -> Dict [ str , Any ]: \"\"\"Function to extract both keys and Python object types from specially formatted dictionary keys and make their respective values into Python objects of those types. Args: json_dict (Dict[str, Any]): JSON dictionary that may contain keys in the format type.key_name (e.g. path.root_directory) with corresponding string values representing Python objects of that type. pyobjson_base_custom_subclasses_by_key (dict[str, Type]): Dictionary with lowercase strings of all subclasses of PythonObjectJson as keys and subclasses as values. Returns: dict[str, Any]: Dictionary with both keys and Python object values derived from specially formatted JSON dictionary keys. \"\"\" derived_key_value_pairs = {} for key , value in json_dict . items (): # check if value is a custom object that will be deserialized as its respective object type or if key is # formatted with a single \".\" to indicate a Python builtin value type if key not in pyobjson_base_custom_subclasses_by_key . keys () and key . count ( \".\" ) == 1 : # check if key is formatted with a single \".\" to indicate a value type type_name , key = key . split ( \".\" ) type_category = None if type_name . count ( \":\" ) == 1 : type_category , type_name = type_name . split ( \":\" ) if type_category == \"collection\" : if type_name == \"dict\" : # do nothing because JSON supports dictionaries pass elif type_name == \"list\" : # do nothing because JSON supports lists pass elif type_name == \"set\" : value = set ( value ) elif type_name == \"tuple\" : value = tuple ( value ) elif type_name == \"bytes\" or type_name == \"bytearray\" : value = b64decode ( value ) elif type_name == \"path\" : # handle posix paths value = Path ( value ) elif type_name == \"callable\" : # handle callables (functions, methods, etc.) # extract the callable components from a value with format module.callable::arg1:type1,arg2:type2 callable_path , callable_args = value . split ( \"::\" , 1 ) # extract the callable module and name module , callable_name = callable_path . rsplit ( \".\" , 1 ) # use the callable module and name to import the callable itself and set it to the value value = getattr ( import_module ( module ), callable_name ) elif type_name == \"datetime\" : # handle datetime objects value = datetime . fromisoformat ( value ) else : raise ValueError ( f \"JSON data ( { key } : { value } ) is not compatible with pyobjson.\" ) derived_key_value_pairs [ key ] = value return derived_key_value_pairs","title":"extract_typed_key_value_pairs"},{"location":"data/#src.pyobjson.data.serialize","text":"serialize ( obj , pyobjson_base_custom_subclasses , excluded_attributes , ) Recursive function to serialize custom Python objects into nested dictionaries for conversion to JSON. Parameters: obj ( Any ) \u2013 Python object to serialize. pyobjson_base_custom_subclasses ( list [ Type ] ) \u2013 List of custom Python class subclasses. excluded_attributes ( list [ str ] ) \u2013 List of attributes to exclude from serialization. Supports substring matching exclusions. Returns: Any \u2013 dict[str, Any]: Serializable dictionary. Source code in src/pyobjson/data.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 def serialize ( obj : Any , pyobjson_base_custom_subclasses : List [ Type ], excluded_attributes : List [ str ]) -> Any : \"\"\"Recursive function to serialize custom Python objects into nested dictionaries for conversion to JSON. Args: obj (Any): Python object to serialize. pyobjson_base_custom_subclasses (list[Type]): List of custom Python class subclasses. excluded_attributes (list[str]): List of attributes to exclude from serialization. Supports substring matching exclusions. Returns: dict[str, Any]: Serializable dictionary. \"\"\" if type ( obj ) in pyobjson_base_custom_subclasses : serializable_obj = {} attributes = { k : v for k , v in unpack_custom_class_vars ( obj , pyobjson_base_custom_subclasses , excluded_attributes ) . items () } for att , val in attributes . items (): if isinstance ( val , dict ): # noinspection PyUnboundLocalVariable if ( len ( val ) == 1 and ( single_key := next ( iter ( val . keys ()))) and single_key in [ derive_custom_object_key ( subclass ) for subclass in pyobjson_base_custom_subclasses ] ): # do nothing because attribute key for custom Python object is already formatted correctly by # unpack custom_class_vars() pass else : att = f \"collection:dict. { att } \" elif isinstance ( val , ( list , set , tuple , bytes , bytearray )): att = f \"collection: { derive_custom_object_key ( val . __class__ ) } . { att } \" elif isinstance ( val , Path ): att = f \"path. { att } \" elif isinstance ( val , Callable ): att = f \"callable. { att } \" elif isinstance ( val , datetime ): att = f \"datetime. { att } \" else : try : json . dumps ( val ) except TypeError as e : if str ( e ) == f \"Object of type { type ( val ) . __name__ } is not JSON serializable\" : att = f \"repr: { derive_custom_object_key ( val . __class__ ) } \" else : att = f \"UNSERIALIZABLE. { derive_custom_object_key ( val . __class__ ) } \" serializable_obj [ att ] = serialize ( val , pyobjson_base_custom_subclasses , excluded_attributes ) return { derive_custom_object_key ( obj . __class__ ): serializable_obj } elif isinstance ( obj , dict ): return { k : serialize ( v , pyobjson_base_custom_subclasses , excluded_attributes ) for k , v in obj . items ()} elif isinstance ( obj , ( list , set , tuple )): return [ serialize ( v , pyobjson_base_custom_subclasses , excluded_attributes ) for v in obj ] elif isinstance ( obj , ( bytes , bytearray )): return b64encode ( obj ) . decode ( \"utf-8\" ) elif isinstance ( obj , Path ): return str ( obj ) elif isinstance ( obj , Callable ): return derive_custom_callable_value ( obj ) elif isinstance ( obj , datetime ): return obj . isoformat () else : try : json . dumps ( obj ) except TypeError as e : if str ( e ) == f \"Object of type { type ( obj ) . __name__ } is not JSON serializable\" : return repr ( obj ) else : return \"UNSERIALIZABLE\" return obj","title":"serialize"},{"location":"data/#src.pyobjson.data.deserialize","text":"deserialize ( json_data , pyobjson_base_custom_subclasses_by_key , base_class_instance = None , extra_instance_atts = None , ) Recursive function to deserialize JSON into typed data structures for conversion to custom Python objects. Parameters: json_data ( Any ) \u2013 JSON data to be deserialized. pyobjson_base_custom_subclasses_by_key ( dict [ str , Type ] ) \u2013 Dictionary with lowercase strings of all subclasses of PythonObjectJson as keys and subclasses as values. base_class_instance ( Optional [ Any ] , default: None ) \u2013 Target class instance into which to deserialize JSON data. extra_instance_atts ( Optional [ Dict [ str , Any ]] , default: None ) \u2013 Dictionary with extra required class attributes for custom Python objects. Returns: obj ( Any ) \u2013 Object deserialized from JSON. Source code in src/pyobjson/data.py 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 def deserialize ( json_data : Any , pyobjson_base_custom_subclasses_by_key : Dict [ str , Type ], base_class_instance : Optional [ Any ] = None , extra_instance_atts : Optional [ Dict [ str , Any ]] = None , ) -> Any : \"\"\"Recursive function to deserialize JSON into typed data structures for conversion to custom Python objects. Args: json_data (Any): JSON data to be deserialized. pyobjson_base_custom_subclasses_by_key (dict[str, Type]): Dictionary with lowercase strings of all subclasses of PythonObjectJson as keys and subclasses as values. base_class_instance (Optional[Any]): Target class instance into which to deserialize JSON data. extra_instance_atts (Optional[Dict[str, Any]]): Dictionary with extra required class attributes for custom Python objects. Returns: obj (Any): Object deserialized from JSON. \"\"\" if not extra_instance_atts : extra_instance_atts = {} base_subclasses : Dict [ str , Type ] = pyobjson_base_custom_subclasses_by_key if isinstance ( json_data , list ): # recursively deserialize all elements if json_data is a list return [ deserialize ( item , base_subclasses , extra_instance_atts = extra_instance_atts ) for item in json_data ] elif isinstance ( json_data , dict ): # recursively deserialize all values if json_data is a dictionary # check if json_data is a dict with only one key that matches a custom subclass for object derivation # noinspection PyUnboundLocalVariable if len ( json_data ) == 1 and ( single_key := next ( iter ( json_data . keys ()))) and single_key in base_subclasses : # noinspection PyPep8Naming ClassObject = base_subclasses [ single_key ] # retrieve custom subclass class_args = getfullargspec ( ClassObject . __init__ ) . args [ 1 :] # get __init__ arguments for custom subclass class_instance_attributes : Dict [ str , Any ] = json_data [ single_key ] # get JSON to be deserialized if ClassObject == base_class_instance . __class__ : # avoid creating a new class instance if an existing base class instance has been provided class_instance = base_class_instance else : # extract original attribute names from pyobjson formatted attribute keys extracted_class_instance_atts = { att . split ( \".\" )[ - 1 ] for att in class_instance_attributes . keys ()} # check if any required instance attributes are missing from the deserialized data if missing_instances_atts := set ( class_args ) . difference ( extracted_class_instance_atts ): if set ( extra_instance_atts . keys ()) . issuperset ( missing_instances_atts ): class_instance_attributes . update ( extra_instance_atts ) else : logger . warning ( f \"Missing required instance attributes \" f '\" { missing_instances_atts . difference ( set ( extra_instance_atts . keys ())) } \" for custom ' f 'class \" { ClassObject . __name__ } \".' ) sys . exit ( 1 ) # create an instance of the custom subclass using the __init__ arguments class_instance = ClassObject ( ** { k : deserialize ( v , base_subclasses , extra_instance_atts = extra_instance_atts ) for k , v in extract_typed_key_value_pairs ( class_instance_attributes , base_subclasses ) . items () if k in class_args } ) # assign the remaining class attributes to the class instance # noinspection PyUnresolvedReferences vars ( class_instance ) . update ( { k : deserialize ( v , base_subclasses , extra_instance_atts = extra_instance_atts ) for k , v in extract_typed_key_value_pairs ( class_instance_attributes , base_subclasses ) . items () } ) return class_instance if not base_class_instance else None else : return { k : deserialize ( v , base_subclasses , extra_instance_atts = extra_instance_atts ) for k , v in extract_typed_key_value_pairs ( json_data , base_subclasses ) . items () } else : return json_data","title":"deserialize"},{"location":"deployment/","text":"Deployment \u00b6 Table of Contents \u00b6 Initial Deployment Subsequent Deployment Initial Deployment \u00b6 (Required for initial publication on PyPI as needed) Register a new account on PyPI (do the same for Test PyPI as needed). (Required for initial publication on PyPI) Configure API token authentication for PyPI by creating an API token (do the same for Test PyPI as needed) and copy the value of the API token. (Required for initial publication on PyPI) Create a .env file by running cp .env.template .env in the command line from the project root directory and paste the PyPI API token from the previous step as the value for UV_PUBLISH_TOKEN (this environment variable is used in the Makefile by uv publish to publish the package using uv ). (Optional after initial package publication on PyPI) Configure a new package-specific PyPI API token and update the above UV_PUBLISH_TOKEN environment variable in the .env to use it. (Optional if using Twine) Install twine (if not already installed) with uv add twine . (Optional if using custom domain for GitHub Pages) Follow the steps for managing a custom domain for GitHub Pages . If you want to use a subdomain, you should follow the steps for configuring a subdomain for GitHub Pages , which require the creation of a CNAME DNS record for your custom domain. Note : If you are using CloudFlare and you create a CNAME record for your GitHub Pages subdomain, you must turn off \u201cProxy status\u201d so that it is \u201cDNS only\u201d or else HTTPS will not work! Subsequent Deployment \u00b6 (Optional) Check pyproject.toml for latest dependency versions. (Optional) Update virtual machine with the latest dependencies ( make update in Makefile): uv sync --all-extras --dev Lint code with ruff ( make lint in Makefile): ruff check . Check code security with bandit ( make secure in Makefile): bandit -c pyproject.toml -r . (Optional) Run all pytest tests (see following commands for running subsets of tests) ( make test_code in Makefile): uv run pytest tests (Optional) Run all pytest tests verbosely : uv run pytest -v -s tests (Optional) Run all tests from pytest file: uv run pytest -v -s tests/test_pyobjson.py (Optional) Run specific test from pytest file: uv run pytest -v -s tests/test_pyobjson.py -k test_main (Optional) Test Python support using act for GitHub Actions: act -j build Note : If act is unable to locate Docker, make sure that the required /var/run/docker.sock symlink exists. If it does not, you can fix it by running: sudo ln -s \" $HOME /.docker/run/docker.sock\" /var/run/docker.sock ` Note : If you are running macOS on a devices with an M-series chip (Apple Silicon), you will need to specify linux/amd64 architecture when running act : act --container-architecture linux/amd64 -j build (Optional) Build the PyPI package independent of deployment: make build (Optional) Test packages for PyPI deployment: make verify_build (Optional) Check MkDocs documentation by serving it at http://localhost:8000/ locally: make test_docs (Optional) Build the PyPI package and MkDocs documentation independent of deployment: make docs Note : Running make test_docs from the previous step recreates the documentation without building the PyPI package. Create a git commit: git add . git commit -m 'commit message' Update the git tag with the new version ( git tag -a [tag_name/version] -m [message] ): git tag -a v1.0.0 -m 'release message' git push origin --tags (Optional) Test deployment by building the PyPI packages, recreating the documentation, and deploying to Test PyPI: make uv_test_deploy Deploy the package by building it, recreating the documentation, and deploying the package to PyPI: make uv_deploy Create a second git commit with updated version number and documentation and update the package git repository ( make git_post_deploy ): git add . git commit -m 'updated version number and documentation' git push (Optional if releasing a major version) Go to the Releases page, click Draft a new release , select the latest major version tag, set the title to Release vX.X.X , enter release notes, and click Publish release .","title":"Deployment"},{"location":"deployment/#deployment","text":"","title":"Deployment"},{"location":"deployment/#table-of-contents","text":"Initial Deployment Subsequent Deployment","title":"Table of Contents"},{"location":"deployment/#initial-deployment","text":"(Required for initial publication on PyPI as needed) Register a new account on PyPI (do the same for Test PyPI as needed). (Required for initial publication on PyPI) Configure API token authentication for PyPI by creating an API token (do the same for Test PyPI as needed) and copy the value of the API token. (Required for initial publication on PyPI) Create a .env file by running cp .env.template .env in the command line from the project root directory and paste the PyPI API token from the previous step as the value for UV_PUBLISH_TOKEN (this environment variable is used in the Makefile by uv publish to publish the package using uv ). (Optional after initial package publication on PyPI) Configure a new package-specific PyPI API token and update the above UV_PUBLISH_TOKEN environment variable in the .env to use it. (Optional if using Twine) Install twine (if not already installed) with uv add twine . (Optional if using custom domain for GitHub Pages) Follow the steps for managing a custom domain for GitHub Pages . If you want to use a subdomain, you should follow the steps for configuring a subdomain for GitHub Pages , which require the creation of a CNAME DNS record for your custom domain. Note : If you are using CloudFlare and you create a CNAME record for your GitHub Pages subdomain, you must turn off \u201cProxy status\u201d so that it is \u201cDNS only\u201d or else HTTPS will not work!","title":"Initial Deployment"},{"location":"deployment/#subsequent-deployment","text":"(Optional) Check pyproject.toml for latest dependency versions. (Optional) Update virtual machine with the latest dependencies ( make update in Makefile): uv sync --all-extras --dev Lint code with ruff ( make lint in Makefile): ruff check . Check code security with bandit ( make secure in Makefile): bandit -c pyproject.toml -r . (Optional) Run all pytest tests (see following commands for running subsets of tests) ( make test_code in Makefile): uv run pytest tests (Optional) Run all pytest tests verbosely : uv run pytest -v -s tests (Optional) Run all tests from pytest file: uv run pytest -v -s tests/test_pyobjson.py (Optional) Run specific test from pytest file: uv run pytest -v -s tests/test_pyobjson.py -k test_main (Optional) Test Python support using act for GitHub Actions: act -j build Note : If act is unable to locate Docker, make sure that the required /var/run/docker.sock symlink exists. If it does not, you can fix it by running: sudo ln -s \" $HOME /.docker/run/docker.sock\" /var/run/docker.sock ` Note : If you are running macOS on a devices with an M-series chip (Apple Silicon), you will need to specify linux/amd64 architecture when running act : act --container-architecture linux/amd64 -j build (Optional) Build the PyPI package independent of deployment: make build (Optional) Test packages for PyPI deployment: make verify_build (Optional) Check MkDocs documentation by serving it at http://localhost:8000/ locally: make test_docs (Optional) Build the PyPI package and MkDocs documentation independent of deployment: make docs Note : Running make test_docs from the previous step recreates the documentation without building the PyPI package. Create a git commit: git add . git commit -m 'commit message' Update the git tag with the new version ( git tag -a [tag_name/version] -m [message] ): git tag -a v1.0.0 -m 'release message' git push origin --tags (Optional) Test deployment by building the PyPI packages, recreating the documentation, and deploying to Test PyPI: make uv_test_deploy Deploy the package by building it, recreating the documentation, and deploying the package to PyPI: make uv_deploy Create a second git commit with updated version number and documentation and update the package git repository ( make git_post_deploy ): git add . git commit -m 'updated version number and documentation' git push (Optional if releasing a major version) Go to the Releases page, click Draft a new release , select the latest major version tag, set the title to Release vX.X.X , enter release notes, and click Publish release .","title":"Subsequent Deployment"},{"location":"mongo/","text":"MongoDB \u00b6 Python Object JSON Tool pyobjson.dao.mongo module. Attributes: __author__ ( str ) \u2013 Python package template author. __email__ ( str ) \u2013 Python package template author email. Classes: Name Description PythonObjectJsonToMongo PythonObjectJson subclass with built-in save/load functionality to/from MongoDB. PythonObjectJsonToMongo \u00b6 Bases: PythonObjectJson PythonObjectJson subclass with built-in save/load functionality to/from MongoDB. Methods: Name Description serialize Create a serializable dictionary from the class instance that excludes MongoDB-related attributes. deserialize Load data to a class instance from a serializable dictionary and add in MongoDB-related attributes. save_to_mongo Save the custom Python object to a specified MongoDB collection. load_from_mongo Load the JSON values from a specified MongoDB document ID to the custom Python object from a specified Source code in src/pyobjson/dao/mongo/base.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 class PythonObjectJsonToMongo ( PythonObjectJson ): \"\"\"PythonObjectJson subclass with built-in save/load functionality to/from MongoDB.\"\"\" def __init__ ( self , mongo_host : str , mongo_port : int , mongo_database : str , mongo_user : str , mongo_password : str ): super () . __init__ () self . mongo_host : str = mongo_host self . mongo_port : int = mongo_port self . mongo_database : str = mongo_database self . mongo_user : str = mongo_user self . mongo_password : str = mongo_password def _get_mongo_client ( self ): \"\"\"Create a MongoDB connection. Returns: MongoClient: A pymongo MongoClient instance. \"\"\" return MongoClient ( f \"mongodb:// { quote_plus ( self . mongo_user ) } : { quote_plus ( self . mongo_password ) } \" f \"@ { self . mongo_host } : { self . mongo_port } / { self . mongo_database } \" f \"?authSource=admin\" , serverSelectionTimeoutMS = 5000 , ) def _validate_or_create_collection ( self , mongo_collection : str ) -> Collection : \"\"\"Create a pymongo Database instance from a pymongo MongoClient, check if a given MongoDB collection exists, and create the collection if it does not exist. Args: mongo_collection (str): The name of the MongoDB collection for which to check existence or create. Returns: Collection: A pymongo Collection instance. \"\"\" db = self . _get_mongo_client ()[ self . mongo_database ] try : db . validate_collection ( mongo_collection ) except ServerSelectionTimeoutError : logger . warning ( f 'Unable to connect to MongoDB server at \" { self . mongo_host } : { self . mongo_port } \".' ) sys . exit ( 1 ) except OperationFailure : logger . debug ( f 'MongoDB collection \" { mongo_collection } \" does not exist.' ) db . create_collection ( mongo_collection ) return db . get_collection ( mongo_collection ) @staticmethod def _validate_document_id ( mongo_document_id : Union [ ObjectId , bytes , str ]) -> None : \"\"\"This method checks to see if a given MongoDB document ID is valid. Args: mongo_document_id (Union[ObjectId, bytes, str]): The MongoDB document ID to validate. Returns: None \"\"\" if not ObjectId . is_valid ( mongo_document_id ): logger . error ( f 'Invalid MongoDb document ID \" { mongo_document_id } \". MongoDB requires document ObjectId values to ' f \"be either 12 bytes long or a 24-character hexadecimal string.\" ) sys . exit ( 1 ) def serialize ( self ) -> Dict [ str , Any ]: \"\"\"Create a serializable dictionary from the class instance that excludes MongoDB-related attributes. Returns: dict[str, Any]: Serializable dictionary representing the class instance without MongoDB-related attributes. \"\"\" return serialize ( self , list ( self . _base_subclasses () . values ()), [ \"mongo_\" ]) def deserialize ( self , serializable_dict : Dict [ str , Any ]) -> Any : \"\"\"Load data to a class instance from a serializable dictionary and add in MongoDB-related attributes. Args: serializable_dict (dict[str, Any]): Serializable dictionary representing the class instance. Returns: Any: Class instance deserialized from data dictionary including MongoDB-related attributes. \"\"\" extra_instance_attributes = { \"mongo_host\" : self . mongo_host , \"mongo_port\" : self . mongo_port , \"mongo_database\" : self . mongo_database , \"mongo_user\" : self . mongo_user , \"mongo_password\" : self . mongo_password , } return deserialize ( serializable_dict , self . _base_subclasses (), base_class_instance = self , extra_instance_atts = extra_instance_attributes , ) def save_to_mongo ( self , mongo_collection : str , mongo_document_id : Optional [ Union [ ObjectId , bytes , str ]] = None ) -> ObjectId : \"\"\"Save the custom Python object to a specified MongoDB collection. Args: mongo_collection (str): The name of the MongoDB collection into which to save the custom Python object. mongo_document_id (Optional[ObjectId, bytes, str], optional): MongoDB document ID. Defaults to None, which will result in MongoDB automatically generating a unique document ID. Returns: ObjectId: The MongoDB document ID to which the custom Python object JSON was saved. \"\"\" # only validate MongoDB document ID if one is provided if mongo_document_id : self . _validate_document_id ( mongo_document_id ) collection = self . _validate_or_create_collection ( mongo_collection ) document : Dict [ str , Any ] = collection . find_one_and_update ( { \"_id\" : ObjectId ( mongo_document_id ) if mongo_document_id else ObjectId ()}, { \"$set\" : { \"custom_class\" : self . serialize ()}}, projection = { \"_id\" : True }, # filter out all fields besides the document ID upsert = True , # create a new document if it does not exist, otherwise update the existing document return_document = ReturnDocument . AFTER , # return the updated or created document after the update/creation ) return document [ \"_id\" ] def load_from_mongo ( self , mongo_collection : str , mongo_document_id : Union [ ObjectId , bytes , str ]) -> None : \"\"\"Load the JSON values from a specified MongoDB document ID to the custom Python object from a specified MongoDB collection. Args: mongo_collection (str): The name of the MongoDB collection from which to load the custom Python object data. mongo_document_id (Union[ObjectId, bytes, str]): The MongoDB document ID from which the custom Python object JSON was loaded. Returns: None \"\"\" self . _validate_document_id ( mongo_document_id ) # get MongoDb collection collection = self . _validate_or_create_collection ( mongo_collection ) self . deserialize ( collection . find_one ({ \"_id\" : ObjectId ( mongo_document_id )}) . get ( \"custom_class\" )) serialize \u00b6 serialize () Create a serializable dictionary from the class instance that excludes MongoDB-related attributes. Returns: Dict [ str , Any ] \u2013 dict[str, Any]: Serializable dictionary representing the class instance without MongoDB-related attributes. Source code in src/pyobjson/dao/mongo/base.py 96 97 98 99 100 101 102 103 def serialize ( self ) -> Dict [ str , Any ]: \"\"\"Create a serializable dictionary from the class instance that excludes MongoDB-related attributes. Returns: dict[str, Any]: Serializable dictionary representing the class instance without MongoDB-related attributes. \"\"\" return serialize ( self , list ( self . _base_subclasses () . values ()), [ \"mongo_\" ]) deserialize \u00b6 deserialize ( serializable_dict ) Load data to a class instance from a serializable dictionary and add in MongoDB-related attributes. Parameters: serializable_dict ( dict [ str , Any ] ) \u2013 Serializable dictionary representing the class instance. Returns: Any ( Any ) \u2013 Class instance deserialized from data dictionary including MongoDB-related attributes. Source code in src/pyobjson/dao/mongo/base.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def deserialize ( self , serializable_dict : Dict [ str , Any ]) -> Any : \"\"\"Load data to a class instance from a serializable dictionary and add in MongoDB-related attributes. Args: serializable_dict (dict[str, Any]): Serializable dictionary representing the class instance. Returns: Any: Class instance deserialized from data dictionary including MongoDB-related attributes. \"\"\" extra_instance_attributes = { \"mongo_host\" : self . mongo_host , \"mongo_port\" : self . mongo_port , \"mongo_database\" : self . mongo_database , \"mongo_user\" : self . mongo_user , \"mongo_password\" : self . mongo_password , } return deserialize ( serializable_dict , self . _base_subclasses (), base_class_instance = self , extra_instance_atts = extra_instance_attributes , ) save_to_mongo \u00b6 save_to_mongo ( mongo_collection , mongo_document_id = None ) Save the custom Python object to a specified MongoDB collection. Parameters: mongo_collection ( str ) \u2013 The name of the MongoDB collection into which to save the custom Python object. mongo_document_id ( Optional [ ObjectId , bytes , str ] , default: None ) \u2013 MongoDB document ID. Defaults to None, which will result in MongoDB automatically generating a unique document ID. Returns: ObjectId ( ObjectId ) \u2013 The MongoDB document ID to which the custom Python object JSON was saved. Source code in src/pyobjson/dao/mongo/base.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def save_to_mongo ( self , mongo_collection : str , mongo_document_id : Optional [ Union [ ObjectId , bytes , str ]] = None ) -> ObjectId : \"\"\"Save the custom Python object to a specified MongoDB collection. Args: mongo_collection (str): The name of the MongoDB collection into which to save the custom Python object. mongo_document_id (Optional[ObjectId, bytes, str], optional): MongoDB document ID. Defaults to None, which will result in MongoDB automatically generating a unique document ID. Returns: ObjectId: The MongoDB document ID to which the custom Python object JSON was saved. \"\"\" # only validate MongoDB document ID if one is provided if mongo_document_id : self . _validate_document_id ( mongo_document_id ) collection = self . _validate_or_create_collection ( mongo_collection ) document : Dict [ str , Any ] = collection . find_one_and_update ( { \"_id\" : ObjectId ( mongo_document_id ) if mongo_document_id else ObjectId ()}, { \"$set\" : { \"custom_class\" : self . serialize ()}}, projection = { \"_id\" : True }, # filter out all fields besides the document ID upsert = True , # create a new document if it does not exist, otherwise update the existing document return_document = ReturnDocument . AFTER , # return the updated or created document after the update/creation ) return document [ \"_id\" ] load_from_mongo \u00b6 load_from_mongo ( mongo_collection , mongo_document_id ) Load the JSON values from a specified MongoDB document ID to the custom Python object from a specified MongoDB collection. Parameters: mongo_collection ( str ) \u2013 The name of the MongoDB collection from which to load the custom Python object data. mongo_document_id ( Union [ ObjectId , bytes , str ] ) \u2013 The MongoDB document ID from which the custom Python object JSON was loaded. Returns: None \u2013 None Source code in src/pyobjson/dao/mongo/base.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def load_from_mongo ( self , mongo_collection : str , mongo_document_id : Union [ ObjectId , bytes , str ]) -> None : \"\"\"Load the JSON values from a specified MongoDB document ID to the custom Python object from a specified MongoDB collection. Args: mongo_collection (str): The name of the MongoDB collection from which to load the custom Python object data. mongo_document_id (Union[ObjectId, bytes, str]): The MongoDB document ID from which the custom Python object JSON was loaded. Returns: None \"\"\" self . _validate_document_id ( mongo_document_id ) # get MongoDb collection collection = self . _validate_or_create_collection ( mongo_collection ) self . deserialize ( collection . find_one ({ \"_id\" : ObjectId ( mongo_document_id )}) . get ( \"custom_class\" ))","title":"pyobjson.dao.mongo"},{"location":"mongo/#mongodb","text":"Python Object JSON Tool pyobjson.dao.mongo module. Attributes: __author__ ( str ) \u2013 Python package template author. __email__ ( str ) \u2013 Python package template author email. Classes: Name Description PythonObjectJsonToMongo PythonObjectJson subclass with built-in save/load functionality to/from MongoDB.","title":"MongoDB"},{"location":"mongo/#src.pyobjson.dao.mongo.base.PythonObjectJsonToMongo","text":"Bases: PythonObjectJson PythonObjectJson subclass with built-in save/load functionality to/from MongoDB. Methods: Name Description serialize Create a serializable dictionary from the class instance that excludes MongoDB-related attributes. deserialize Load data to a class instance from a serializable dictionary and add in MongoDB-related attributes. save_to_mongo Save the custom Python object to a specified MongoDB collection. load_from_mongo Load the JSON values from a specified MongoDB document ID to the custom Python object from a specified Source code in src/pyobjson/dao/mongo/base.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 class PythonObjectJsonToMongo ( PythonObjectJson ): \"\"\"PythonObjectJson subclass with built-in save/load functionality to/from MongoDB.\"\"\" def __init__ ( self , mongo_host : str , mongo_port : int , mongo_database : str , mongo_user : str , mongo_password : str ): super () . __init__ () self . mongo_host : str = mongo_host self . mongo_port : int = mongo_port self . mongo_database : str = mongo_database self . mongo_user : str = mongo_user self . mongo_password : str = mongo_password def _get_mongo_client ( self ): \"\"\"Create a MongoDB connection. Returns: MongoClient: A pymongo MongoClient instance. \"\"\" return MongoClient ( f \"mongodb:// { quote_plus ( self . mongo_user ) } : { quote_plus ( self . mongo_password ) } \" f \"@ { self . mongo_host } : { self . mongo_port } / { self . mongo_database } \" f \"?authSource=admin\" , serverSelectionTimeoutMS = 5000 , ) def _validate_or_create_collection ( self , mongo_collection : str ) -> Collection : \"\"\"Create a pymongo Database instance from a pymongo MongoClient, check if a given MongoDB collection exists, and create the collection if it does not exist. Args: mongo_collection (str): The name of the MongoDB collection for which to check existence or create. Returns: Collection: A pymongo Collection instance. \"\"\" db = self . _get_mongo_client ()[ self . mongo_database ] try : db . validate_collection ( mongo_collection ) except ServerSelectionTimeoutError : logger . warning ( f 'Unable to connect to MongoDB server at \" { self . mongo_host } : { self . mongo_port } \".' ) sys . exit ( 1 ) except OperationFailure : logger . debug ( f 'MongoDB collection \" { mongo_collection } \" does not exist.' ) db . create_collection ( mongo_collection ) return db . get_collection ( mongo_collection ) @staticmethod def _validate_document_id ( mongo_document_id : Union [ ObjectId , bytes , str ]) -> None : \"\"\"This method checks to see if a given MongoDB document ID is valid. Args: mongo_document_id (Union[ObjectId, bytes, str]): The MongoDB document ID to validate. Returns: None \"\"\" if not ObjectId . is_valid ( mongo_document_id ): logger . error ( f 'Invalid MongoDb document ID \" { mongo_document_id } \". MongoDB requires document ObjectId values to ' f \"be either 12 bytes long or a 24-character hexadecimal string.\" ) sys . exit ( 1 ) def serialize ( self ) -> Dict [ str , Any ]: \"\"\"Create a serializable dictionary from the class instance that excludes MongoDB-related attributes. Returns: dict[str, Any]: Serializable dictionary representing the class instance without MongoDB-related attributes. \"\"\" return serialize ( self , list ( self . _base_subclasses () . values ()), [ \"mongo_\" ]) def deserialize ( self , serializable_dict : Dict [ str , Any ]) -> Any : \"\"\"Load data to a class instance from a serializable dictionary and add in MongoDB-related attributes. Args: serializable_dict (dict[str, Any]): Serializable dictionary representing the class instance. Returns: Any: Class instance deserialized from data dictionary including MongoDB-related attributes. \"\"\" extra_instance_attributes = { \"mongo_host\" : self . mongo_host , \"mongo_port\" : self . mongo_port , \"mongo_database\" : self . mongo_database , \"mongo_user\" : self . mongo_user , \"mongo_password\" : self . mongo_password , } return deserialize ( serializable_dict , self . _base_subclasses (), base_class_instance = self , extra_instance_atts = extra_instance_attributes , ) def save_to_mongo ( self , mongo_collection : str , mongo_document_id : Optional [ Union [ ObjectId , bytes , str ]] = None ) -> ObjectId : \"\"\"Save the custom Python object to a specified MongoDB collection. Args: mongo_collection (str): The name of the MongoDB collection into which to save the custom Python object. mongo_document_id (Optional[ObjectId, bytes, str], optional): MongoDB document ID. Defaults to None, which will result in MongoDB automatically generating a unique document ID. Returns: ObjectId: The MongoDB document ID to which the custom Python object JSON was saved. \"\"\" # only validate MongoDB document ID if one is provided if mongo_document_id : self . _validate_document_id ( mongo_document_id ) collection = self . _validate_or_create_collection ( mongo_collection ) document : Dict [ str , Any ] = collection . find_one_and_update ( { \"_id\" : ObjectId ( mongo_document_id ) if mongo_document_id else ObjectId ()}, { \"$set\" : { \"custom_class\" : self . serialize ()}}, projection = { \"_id\" : True }, # filter out all fields besides the document ID upsert = True , # create a new document if it does not exist, otherwise update the existing document return_document = ReturnDocument . AFTER , # return the updated or created document after the update/creation ) return document [ \"_id\" ] def load_from_mongo ( self , mongo_collection : str , mongo_document_id : Union [ ObjectId , bytes , str ]) -> None : \"\"\"Load the JSON values from a specified MongoDB document ID to the custom Python object from a specified MongoDB collection. Args: mongo_collection (str): The name of the MongoDB collection from which to load the custom Python object data. mongo_document_id (Union[ObjectId, bytes, str]): The MongoDB document ID from which the custom Python object JSON was loaded. Returns: None \"\"\" self . _validate_document_id ( mongo_document_id ) # get MongoDb collection collection = self . _validate_or_create_collection ( mongo_collection ) self . deserialize ( collection . find_one ({ \"_id\" : ObjectId ( mongo_document_id )}) . get ( \"custom_class\" ))","title":"PythonObjectJsonToMongo"},{"location":"mongo/#src.pyobjson.dao.mongo.base.PythonObjectJsonToMongo.serialize","text":"serialize () Create a serializable dictionary from the class instance that excludes MongoDB-related attributes. Returns: Dict [ str , Any ] \u2013 dict[str, Any]: Serializable dictionary representing the class instance without MongoDB-related attributes. Source code in src/pyobjson/dao/mongo/base.py 96 97 98 99 100 101 102 103 def serialize ( self ) -> Dict [ str , Any ]: \"\"\"Create a serializable dictionary from the class instance that excludes MongoDB-related attributes. Returns: dict[str, Any]: Serializable dictionary representing the class instance without MongoDB-related attributes. \"\"\" return serialize ( self , list ( self . _base_subclasses () . values ()), [ \"mongo_\" ])","title":"serialize"},{"location":"mongo/#src.pyobjson.dao.mongo.base.PythonObjectJsonToMongo.deserialize","text":"deserialize ( serializable_dict ) Load data to a class instance from a serializable dictionary and add in MongoDB-related attributes. Parameters: serializable_dict ( dict [ str , Any ] ) \u2013 Serializable dictionary representing the class instance. Returns: Any ( Any ) \u2013 Class instance deserialized from data dictionary including MongoDB-related attributes. Source code in src/pyobjson/dao/mongo/base.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def deserialize ( self , serializable_dict : Dict [ str , Any ]) -> Any : \"\"\"Load data to a class instance from a serializable dictionary and add in MongoDB-related attributes. Args: serializable_dict (dict[str, Any]): Serializable dictionary representing the class instance. Returns: Any: Class instance deserialized from data dictionary including MongoDB-related attributes. \"\"\" extra_instance_attributes = { \"mongo_host\" : self . mongo_host , \"mongo_port\" : self . mongo_port , \"mongo_database\" : self . mongo_database , \"mongo_user\" : self . mongo_user , \"mongo_password\" : self . mongo_password , } return deserialize ( serializable_dict , self . _base_subclasses (), base_class_instance = self , extra_instance_atts = extra_instance_attributes , )","title":"deserialize"},{"location":"mongo/#src.pyobjson.dao.mongo.base.PythonObjectJsonToMongo.save_to_mongo","text":"save_to_mongo ( mongo_collection , mongo_document_id = None ) Save the custom Python object to a specified MongoDB collection. Parameters: mongo_collection ( str ) \u2013 The name of the MongoDB collection into which to save the custom Python object. mongo_document_id ( Optional [ ObjectId , bytes , str ] , default: None ) \u2013 MongoDB document ID. Defaults to None, which will result in MongoDB automatically generating a unique document ID. Returns: ObjectId ( ObjectId ) \u2013 The MongoDB document ID to which the custom Python object JSON was saved. Source code in src/pyobjson/dao/mongo/base.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def save_to_mongo ( self , mongo_collection : str , mongo_document_id : Optional [ Union [ ObjectId , bytes , str ]] = None ) -> ObjectId : \"\"\"Save the custom Python object to a specified MongoDB collection. Args: mongo_collection (str): The name of the MongoDB collection into which to save the custom Python object. mongo_document_id (Optional[ObjectId, bytes, str], optional): MongoDB document ID. Defaults to None, which will result in MongoDB automatically generating a unique document ID. Returns: ObjectId: The MongoDB document ID to which the custom Python object JSON was saved. \"\"\" # only validate MongoDB document ID if one is provided if mongo_document_id : self . _validate_document_id ( mongo_document_id ) collection = self . _validate_or_create_collection ( mongo_collection ) document : Dict [ str , Any ] = collection . find_one_and_update ( { \"_id\" : ObjectId ( mongo_document_id ) if mongo_document_id else ObjectId ()}, { \"$set\" : { \"custom_class\" : self . serialize ()}}, projection = { \"_id\" : True }, # filter out all fields besides the document ID upsert = True , # create a new document if it does not exist, otherwise update the existing document return_document = ReturnDocument . AFTER , # return the updated or created document after the update/creation ) return document [ \"_id\" ]","title":"save_to_mongo"},{"location":"mongo/#src.pyobjson.dao.mongo.base.PythonObjectJsonToMongo.load_from_mongo","text":"load_from_mongo ( mongo_collection , mongo_document_id ) Load the JSON values from a specified MongoDB document ID to the custom Python object from a specified MongoDB collection. Parameters: mongo_collection ( str ) \u2013 The name of the MongoDB collection from which to load the custom Python object data. mongo_document_id ( Union [ ObjectId , bytes , str ] ) \u2013 The MongoDB document ID from which the custom Python object JSON was loaded. Returns: None \u2013 None Source code in src/pyobjson/dao/mongo/base.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def load_from_mongo ( self , mongo_collection : str , mongo_document_id : Union [ ObjectId , bytes , str ]) -> None : \"\"\"Load the JSON values from a specified MongoDB document ID to the custom Python object from a specified MongoDB collection. Args: mongo_collection (str): The name of the MongoDB collection from which to load the custom Python object data. mongo_document_id (Union[ObjectId, bytes, str]): The MongoDB document ID from which the custom Python object JSON was loaded. Returns: None \"\"\" self . _validate_document_id ( mongo_document_id ) # get MongoDb collection collection = self . _validate_or_create_collection ( mongo_collection ) self . deserialize ( collection . find_one ({ \"_id\" : ObjectId ( mongo_document_id )}) . get ( \"custom_class\" ))","title":"load_from_mongo"},{"location":"tests/","text":"PyTest \u00b6 Modules: Name Description conftest Pytest top-level conftest.py. test_pyobjson Pytest test for Python Object JSON Tool code. conftest \u00b6 Pytest top-level conftest.py. Classes: Name Description ThirdClass ThirdClass for testing. SecondClass SecondClass for testing. FirstClass FirstClass for testing. Functions: Name Description ext_func Function external_function for testing. external_function External function for testing. first_class_with_empty_arguments Create FirstClass instance with empty arguments for testing. first_class_with_nested_child_classes Create FirstClass instance for testing. first_class_json_str Create JSON string from FirstClass instance for testing. ThirdClass \u00b6 Bases: PythonObjectJson ThirdClass for testing. Source code in tests/conftest.py 21 22 23 24 25 26 class ThirdClass ( PythonObjectJson ): \"\"\"ThirdClass for testing.\"\"\" def __init__ ( self , third_class_param : str ): super () . __init__ () self . third_class_param : str = third_class_param SecondClass \u00b6 Bases: PythonObjectJson SecondClass for testing. Source code in tests/conftest.py 29 30 31 32 33 34 35 class SecondClass ( PythonObjectJson ): \"\"\"SecondClass for testing.\"\"\" def __init__ ( self , third_class_list : List [ ThirdClass ]): super () . __init__ () self . third_class_list : List [ ThirdClass ] = third_class_list self . third_class_list_dict : Dict [ str , List [ ThirdClass ]] = { \"third_class_list_1\" : third_class_list } FirstClass \u00b6 Bases: PythonObjectJson FirstClass for testing. Source code in tests/conftest.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class FirstClass ( PythonObjectJson ): \"\"\"FirstClass for testing.\"\"\" def __init__ ( self , second_class_dict : Dict [ str , SecondClass ], second_class_list : List [ SecondClass ], first_class_attribute : Optional [ str ], first_class_set : Optional [ Set [ str ]], first_class_tuple : Optional [ Tuple [ str ]], first_class_bytes : Optional [ bytes ], first_class_file : Optional [ Path ], first_class_external_function : Optional [ Callable ], first_class_datetime : Optional [ datetime ], ): super () . __init__ () self . second_class_dict : Dict [ str , SecondClass ] = second_class_dict self . second_class_list : List [ SecondClass ] = second_class_list self . first_class_attribute : str = first_class_attribute self . first_class_set : Set [ str ] = first_class_set self . first_class_tuple : Tuple [ str ] = first_class_tuple self . first_class_bytes : bytes = first_class_bytes self . first_class_file : Path = first_class_file self . first_class_external_function : Optional [ Callable ] = first_class_external_function self . first_class_datetime : datetime = first_class_datetime ext_func \u00b6 ext_func ( param_1 , param_2 ) Function external_function for testing. Source code in tests/conftest.py 16 17 18 def ext_func ( param_1 : str , param_2 : str ): \"\"\"Function external_function for testing.\"\"\" return f \" { param_1 } . { param_2 } \" external_function \u00b6 external_function () External function for testing. Source code in tests/conftest.py 65 66 67 68 @fixture ( scope = \"module\" ) def external_function () -> Callable : \"\"\"External function for testing.\"\"\" return ext_func first_class_with_empty_arguments \u00b6 first_class_with_empty_arguments () Create FirstClass instance with empty arguments for testing. Returns: FirstClass ( FirstClass ) \u2013 Instance of FirstClass with all empty arguments. Source code in tests/conftest.py 71 72 73 74 75 76 77 78 79 @fixture ( scope = \"module\" ) def first_class_with_empty_arguments () -> FirstClass : \"\"\"Create FirstClass instance with empty arguments for testing. Returns: FirstClass: Instance of FirstClass with all empty arguments. \"\"\" return FirstClass ({}, [], None , None , None , None , None , None , None ) first_class_with_nested_child_classes \u00b6 first_class_with_nested_child_classes ( external_function ) Create FirstClass instance for testing. Returns: FirstClass ( FirstClass ) \u2013 Instance of FirstClass. Source code in tests/conftest.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 @fixture ( scope = \"module\" ) def first_class_with_nested_child_classes ( external_function ) -> FirstClass : \"\"\"Create FirstClass instance for testing. Returns: FirstClass: Instance of FirstClass. \"\"\" return FirstClass ( { \"second_class_1\" : SecondClass ([ ThirdClass ( \"test_third_class_argument_in_dict\" )])}, [ SecondClass ([ ThirdClass ( \"test_third_class_argument_in_list\" )])], \"test_first_class_attribute_string\" , { \"test_first_class_collection_element\" }, ( \"test_first_class_collection_element\" ,), b \"test_first_class_collection_element\" , Path ( __name__ ), external_function , datetime ( 2024 , 1 , 1 , 0 , 0 , 0 ), ) first_class_json_str \u00b6 first_class_json_str () Create JSON string from FirstClass instance for testing. Returns: str ( str ) \u2013 JSON string derived from serialized FirstClass instance. Source code in tests/conftest.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 @fixture ( scope = \"module\" ) def first_class_json_str () -> str : \"\"\"Create JSON string from FirstClass instance for testing. Returns: str: JSON string derived from serialized FirstClass instance. \"\"\" return json . dumps ( { \"conftest.firstclass\" : { \"collection:dict.second_class_dict\" : { \"second_class_1\" : { \"conftest.secondclass\" : { \"collection:list.third_class_list\" : [ { \"conftest.thirdclass\" : { \"third_class_param\" : \"test_third_class_argument_in_dict\" }} ], \"collection:dict.third_class_list_dict\" : { \"third_class_list_1\" : [ { \"conftest.thirdclass\" : { \"third_class_param\" : \"test_third_class_argument_in_dict\" }} ] }, } } }, \"collection:list.second_class_list\" : [ { \"conftest.secondclass\" : { \"collection:list.third_class_list\" : [ { \"conftest.thirdclass\" : { \"third_class_param\" : \"test_third_class_argument_in_list\" }} ], \"collection:dict.third_class_list_dict\" : { \"third_class_list_1\" : [ { \"conftest.thirdclass\" : { \"third_class_param\" : \"test_third_class_argument_in_list\" }} ] }, } } ], \"first_class_attribute\" : \"test_first_class_attribute_string\" , \"collection:set.first_class_set\" : [ \"test_first_class_collection_element\" ], \"collection:tuple.first_class_tuple\" : [ \"test_first_class_collection_element\" ], \"collection:bytes.first_class_bytes\" : \"dGVzdF9maXJzdF9jbGFzc19jb2xsZWN0aW9uX2VsZW1lbnQ=\" , \"path.first_class_file\" : \"conftest\" , \"callable.first_class_external_function\" : \"conftest.ext_func::param_1:str,param_2:str\" , \"datetime.first_class_datetime\" : \"2024-01-01T00:00:00\" , } }, ensure_ascii = False , indent = 2 , ) test_pyobjson \u00b6 Pytest test for Python Object JSON Tool code. Note Tests pyobjson.base module. Classes: Name Description TestPythonObjectJson Pytest class for PythonObjectJson functionality. TestPythonObjectJson \u00b6 Pytest class for PythonObjectJson functionality. Source code in tests/test_pyobjson.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class TestPythonObjectJson : \"\"\"Pytest class for PythonObjectJson functionality.\"\"\" def test_serialization_to_json_string ( self , first_class_with_nested_child_classes , first_class_json_str ): # confirm conftest.FirstClass instance as a JSON string is equal to the conftest FirstClass JSON string assert first_class_with_nested_child_classes . to_json_str () == first_class_json_str def test_deserialization_from_json_string ( self , first_class_with_empty_arguments , first_class_with_nested_child_classes , first_class_json_str ): # create new FirstClass instance with all empty/None arguments first_class_instance = first_class_with_empty_arguments # confirm new empty FirstClass instance is not equivalent to conftest.FirstClass instance assert first_class_instance != first_class_with_nested_child_classes # load conftest FirstClass JSON string to new empty FirstClass instance first_class_instance . from_json_str ( first_class_json_str ) # confirm newly created FirstClass instance loaded from JSON is equivalent to conftest.FirstClass instance assert first_class_instance == first_class_with_nested_child_classes","title":"PyTest"},{"location":"tests/#pytest","text":"Modules: Name Description conftest Pytest top-level conftest.py. test_pyobjson Pytest test for Python Object JSON Tool code.","title":"PyTest"},{"location":"tests/#tests.conftest","text":"Pytest top-level conftest.py. Classes: Name Description ThirdClass ThirdClass for testing. SecondClass SecondClass for testing. FirstClass FirstClass for testing. Functions: Name Description ext_func Function external_function for testing. external_function External function for testing. first_class_with_empty_arguments Create FirstClass instance with empty arguments for testing. first_class_with_nested_child_classes Create FirstClass instance for testing. first_class_json_str Create JSON string from FirstClass instance for testing.","title":"conftest"},{"location":"tests/#tests.conftest.ThirdClass","text":"Bases: PythonObjectJson ThirdClass for testing. Source code in tests/conftest.py 21 22 23 24 25 26 class ThirdClass ( PythonObjectJson ): \"\"\"ThirdClass for testing.\"\"\" def __init__ ( self , third_class_param : str ): super () . __init__ () self . third_class_param : str = third_class_param","title":"ThirdClass"},{"location":"tests/#tests.conftest.SecondClass","text":"Bases: PythonObjectJson SecondClass for testing. Source code in tests/conftest.py 29 30 31 32 33 34 35 class SecondClass ( PythonObjectJson ): \"\"\"SecondClass for testing.\"\"\" def __init__ ( self , third_class_list : List [ ThirdClass ]): super () . __init__ () self . third_class_list : List [ ThirdClass ] = third_class_list self . third_class_list_dict : Dict [ str , List [ ThirdClass ]] = { \"third_class_list_1\" : third_class_list }","title":"SecondClass"},{"location":"tests/#tests.conftest.FirstClass","text":"Bases: PythonObjectJson FirstClass for testing. Source code in tests/conftest.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class FirstClass ( PythonObjectJson ): \"\"\"FirstClass for testing.\"\"\" def __init__ ( self , second_class_dict : Dict [ str , SecondClass ], second_class_list : List [ SecondClass ], first_class_attribute : Optional [ str ], first_class_set : Optional [ Set [ str ]], first_class_tuple : Optional [ Tuple [ str ]], first_class_bytes : Optional [ bytes ], first_class_file : Optional [ Path ], first_class_external_function : Optional [ Callable ], first_class_datetime : Optional [ datetime ], ): super () . __init__ () self . second_class_dict : Dict [ str , SecondClass ] = second_class_dict self . second_class_list : List [ SecondClass ] = second_class_list self . first_class_attribute : str = first_class_attribute self . first_class_set : Set [ str ] = first_class_set self . first_class_tuple : Tuple [ str ] = first_class_tuple self . first_class_bytes : bytes = first_class_bytes self . first_class_file : Path = first_class_file self . first_class_external_function : Optional [ Callable ] = first_class_external_function self . first_class_datetime : datetime = first_class_datetime","title":"FirstClass"},{"location":"tests/#tests.conftest.ext_func","text":"ext_func ( param_1 , param_2 ) Function external_function for testing. Source code in tests/conftest.py 16 17 18 def ext_func ( param_1 : str , param_2 : str ): \"\"\"Function external_function for testing.\"\"\" return f \" { param_1 } . { param_2 } \"","title":"ext_func"},{"location":"tests/#tests.conftest.external_function","text":"external_function () External function for testing. Source code in tests/conftest.py 65 66 67 68 @fixture ( scope = \"module\" ) def external_function () -> Callable : \"\"\"External function for testing.\"\"\" return ext_func","title":"external_function"},{"location":"tests/#tests.conftest.first_class_with_empty_arguments","text":"first_class_with_empty_arguments () Create FirstClass instance with empty arguments for testing. Returns: FirstClass ( FirstClass ) \u2013 Instance of FirstClass with all empty arguments. Source code in tests/conftest.py 71 72 73 74 75 76 77 78 79 @fixture ( scope = \"module\" ) def first_class_with_empty_arguments () -> FirstClass : \"\"\"Create FirstClass instance with empty arguments for testing. Returns: FirstClass: Instance of FirstClass with all empty arguments. \"\"\" return FirstClass ({}, [], None , None , None , None , None , None , None )","title":"first_class_with_empty_arguments"},{"location":"tests/#tests.conftest.first_class_with_nested_child_classes","text":"first_class_with_nested_child_classes ( external_function ) Create FirstClass instance for testing. Returns: FirstClass ( FirstClass ) \u2013 Instance of FirstClass. Source code in tests/conftest.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 @fixture ( scope = \"module\" ) def first_class_with_nested_child_classes ( external_function ) -> FirstClass : \"\"\"Create FirstClass instance for testing. Returns: FirstClass: Instance of FirstClass. \"\"\" return FirstClass ( { \"second_class_1\" : SecondClass ([ ThirdClass ( \"test_third_class_argument_in_dict\" )])}, [ SecondClass ([ ThirdClass ( \"test_third_class_argument_in_list\" )])], \"test_first_class_attribute_string\" , { \"test_first_class_collection_element\" }, ( \"test_first_class_collection_element\" ,), b \"test_first_class_collection_element\" , Path ( __name__ ), external_function , datetime ( 2024 , 1 , 1 , 0 , 0 , 0 ), )","title":"first_class_with_nested_child_classes"},{"location":"tests/#tests.conftest.first_class_json_str","text":"first_class_json_str () Create JSON string from FirstClass instance for testing. Returns: str ( str ) \u2013 JSON string derived from serialized FirstClass instance. Source code in tests/conftest.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 @fixture ( scope = \"module\" ) def first_class_json_str () -> str : \"\"\"Create JSON string from FirstClass instance for testing. Returns: str: JSON string derived from serialized FirstClass instance. \"\"\" return json . dumps ( { \"conftest.firstclass\" : { \"collection:dict.second_class_dict\" : { \"second_class_1\" : { \"conftest.secondclass\" : { \"collection:list.third_class_list\" : [ { \"conftest.thirdclass\" : { \"third_class_param\" : \"test_third_class_argument_in_dict\" }} ], \"collection:dict.third_class_list_dict\" : { \"third_class_list_1\" : [ { \"conftest.thirdclass\" : { \"third_class_param\" : \"test_third_class_argument_in_dict\" }} ] }, } } }, \"collection:list.second_class_list\" : [ { \"conftest.secondclass\" : { \"collection:list.third_class_list\" : [ { \"conftest.thirdclass\" : { \"third_class_param\" : \"test_third_class_argument_in_list\" }} ], \"collection:dict.third_class_list_dict\" : { \"third_class_list_1\" : [ { \"conftest.thirdclass\" : { \"third_class_param\" : \"test_third_class_argument_in_list\" }} ] }, } } ], \"first_class_attribute\" : \"test_first_class_attribute_string\" , \"collection:set.first_class_set\" : [ \"test_first_class_collection_element\" ], \"collection:tuple.first_class_tuple\" : [ \"test_first_class_collection_element\" ], \"collection:bytes.first_class_bytes\" : \"dGVzdF9maXJzdF9jbGFzc19jb2xsZWN0aW9uX2VsZW1lbnQ=\" , \"path.first_class_file\" : \"conftest\" , \"callable.first_class_external_function\" : \"conftest.ext_func::param_1:str,param_2:str\" , \"datetime.first_class_datetime\" : \"2024-01-01T00:00:00\" , } }, ensure_ascii = False , indent = 2 , )","title":"first_class_json_str"},{"location":"tests/#tests.test_pyobjson","text":"Pytest test for Python Object JSON Tool code. Note Tests pyobjson.base module. Classes: Name Description TestPythonObjectJson Pytest class for PythonObjectJson functionality.","title":"test_pyobjson"},{"location":"tests/#tests.test_pyobjson.TestPythonObjectJson","text":"Pytest class for PythonObjectJson functionality. Source code in tests/test_pyobjson.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class TestPythonObjectJson : \"\"\"Pytest class for PythonObjectJson functionality.\"\"\" def test_serialization_to_json_string ( self , first_class_with_nested_child_classes , first_class_json_str ): # confirm conftest.FirstClass instance as a JSON string is equal to the conftest FirstClass JSON string assert first_class_with_nested_child_classes . to_json_str () == first_class_json_str def test_deserialization_from_json_string ( self , first_class_with_empty_arguments , first_class_with_nested_child_classes , first_class_json_str ): # create new FirstClass instance with all empty/None arguments first_class_instance = first_class_with_empty_arguments # confirm new empty FirstClass instance is not equivalent to conftest.FirstClass instance assert first_class_instance != first_class_with_nested_child_classes # load conftest FirstClass JSON string to new empty FirstClass instance first_class_instance . from_json_str ( first_class_json_str ) # confirm newly created FirstClass instance loaded from JSON is equivalent to conftest.FirstClass instance assert first_class_instance == first_class_with_nested_child_classes","title":"TestPythonObjectJson"},{"location":"utils/","text":"Utilities \u00b6 Python Object JSON Tool pyobjson.utils module. Attributes: __author__ ( str ) \u2013 Python package template author. __email__ ( str ) \u2013 Python package template author email. Functions: Name Description derive_custom_object_key Utility function to derive a key for a custom object representing the fully qualified name of that object. derive_custom_callable_value Utility function to derive a string value from a custom callable object. get_nested_subclasses Recursive utility function to retrieve all nested subclasses of a custom class. derive_custom_object_key \u00b6 derive_custom_object_key ( custom_object , as_lower = True ) Utility function to derive a key for a custom object representing the fully qualified name of that object. Parameters: custom_object ( Type ) \u2013 The custom object for which to derive a key. as_lower ( bool , default: True ) \u2013 Whether the derived key should be returned as a lower case string. Returns: str ( str ) \u2013 The fully qualified name of the object in lowercase (e.g. module.submodule.object). Source code in src/pyobjson/utils.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def derive_custom_object_key ( custom_object : Union [ Type , Callable ], as_lower : bool = True ) -> str : \"\"\"Utility function to derive a key for a custom object representing the fully qualified name of that object. Args: custom_object (Type): The custom object for which to derive a key. as_lower (bool, optional): Whether the derived key should be returned as a lower case string. Returns: str: The fully qualified name of the object in lowercase (e.g. module.submodule.object). \"\"\" if not hasattr ( custom_object , \"__qualname__\" ): custom_object = custom_object . __class__ # avoid including module if no module exists or the object is in the Python builtins if ( obj_module := getattr ( custom_object , \"__module__\" , None )) and obj_module != \"builtins\" : return ( f \" { obj_module . lower () } . { custom_object . __qualname__ . lower () } \" if as_lower else f \" { obj_module } . { custom_object . __qualname__ } \" ) else : return custom_object . __qualname__ . lower () if as_lower else custom_object . __qualname__ derive_custom_callable_value \u00b6 derive_custom_callable_value ( custom_callable ) Utility function to derive a string value from a custom callable object. Parameters: custom_callable ( Callable ) \u2013 Custom callable object for which to derive a string representation value. Returns: str ( str ) \u2013 A string representing the custom callable object that can be used to import and call that object. Source code in src/pyobjson/utils.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def derive_custom_callable_value ( custom_callable : Callable ) -> str : \"\"\"Utility function to derive a string value from a custom callable object. Args: custom_callable (Callable): Custom callable object for which to derive a string representation value. Returns: str: A string representing the custom callable object that can be used to import and call that object. \"\"\" arg_spec_str = \",\" . join ( [ f \" { k } : { v . __name__ if hasattr ( v , '__name__' ) else v . __class__ . __name__ } \" for k , v in getfullargspec ( custom_callable ) . annotations . items () ] ) return f \" { derive_custom_object_key ( custom_callable ) } :: { arg_spec_str } \" get_nested_subclasses \u00b6 get_nested_subclasses ( custom_class ) Recursive utility function to retrieve all nested subclasses of a custom class. Parameters: custom_class ( Type ) \u2013 Custom class from which to recursively retrieve all nested subclasses. Returns: list ( Type ) \u2013 A list of custom classes derived from the subclass tree of a custom class. Source code in src/pyobjson/utils.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def get_nested_subclasses ( custom_class : Type ) -> List [ Type ]: \"\"\"Recursive utility function to retrieve all nested subclasses of a custom class. Args: custom_class (Type): Custom class from which to recursively retrieve all nested subclasses. Returns: list(Type): A list of custom classes derived from the subclass tree of a custom class. \"\"\" custom_subclasses = custom_class . __subclasses__ () for custom_subclass in custom_subclasses : custom_subclasses . extend ( get_nested_subclasses ( custom_subclass )) return list ( set ( custom_subclasses ))","title":"pyobjson.utils"},{"location":"utils/#utilities","text":"Python Object JSON Tool pyobjson.utils module. Attributes: __author__ ( str ) \u2013 Python package template author. __email__ ( str ) \u2013 Python package template author email. Functions: Name Description derive_custom_object_key Utility function to derive a key for a custom object representing the fully qualified name of that object. derive_custom_callable_value Utility function to derive a string value from a custom callable object. get_nested_subclasses Recursive utility function to retrieve all nested subclasses of a custom class.","title":"Utilities"},{"location":"utils/#src.pyobjson.utils.derive_custom_object_key","text":"derive_custom_object_key ( custom_object , as_lower = True ) Utility function to derive a key for a custom object representing the fully qualified name of that object. Parameters: custom_object ( Type ) \u2013 The custom object for which to derive a key. as_lower ( bool , default: True ) \u2013 Whether the derived key should be returned as a lower case string. Returns: str ( str ) \u2013 The fully qualified name of the object in lowercase (e.g. module.submodule.object). Source code in src/pyobjson/utils.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def derive_custom_object_key ( custom_object : Union [ Type , Callable ], as_lower : bool = True ) -> str : \"\"\"Utility function to derive a key for a custom object representing the fully qualified name of that object. Args: custom_object (Type): The custom object for which to derive a key. as_lower (bool, optional): Whether the derived key should be returned as a lower case string. Returns: str: The fully qualified name of the object in lowercase (e.g. module.submodule.object). \"\"\" if not hasattr ( custom_object , \"__qualname__\" ): custom_object = custom_object . __class__ # avoid including module if no module exists or the object is in the Python builtins if ( obj_module := getattr ( custom_object , \"__module__\" , None )) and obj_module != \"builtins\" : return ( f \" { obj_module . lower () } . { custom_object . __qualname__ . lower () } \" if as_lower else f \" { obj_module } . { custom_object . __qualname__ } \" ) else : return custom_object . __qualname__ . lower () if as_lower else custom_object . __qualname__","title":"derive_custom_object_key"},{"location":"utils/#src.pyobjson.utils.derive_custom_callable_value","text":"derive_custom_callable_value ( custom_callable ) Utility function to derive a string value from a custom callable object. Parameters: custom_callable ( Callable ) \u2013 Custom callable object for which to derive a string representation value. Returns: str ( str ) \u2013 A string representing the custom callable object that can be used to import and call that object. Source code in src/pyobjson/utils.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def derive_custom_callable_value ( custom_callable : Callable ) -> str : \"\"\"Utility function to derive a string value from a custom callable object. Args: custom_callable (Callable): Custom callable object for which to derive a string representation value. Returns: str: A string representing the custom callable object that can be used to import and call that object. \"\"\" arg_spec_str = \",\" . join ( [ f \" { k } : { v . __name__ if hasattr ( v , '__name__' ) else v . __class__ . __name__ } \" for k , v in getfullargspec ( custom_callable ) . annotations . items () ] ) return f \" { derive_custom_object_key ( custom_callable ) } :: { arg_spec_str } \"","title":"derive_custom_callable_value"},{"location":"utils/#src.pyobjson.utils.get_nested_subclasses","text":"get_nested_subclasses ( custom_class ) Recursive utility function to retrieve all nested subclasses of a custom class. Parameters: custom_class ( Type ) \u2013 Custom class from which to recursively retrieve all nested subclasses. Returns: list ( Type ) \u2013 A list of custom classes derived from the subclass tree of a custom class. Source code in src/pyobjson/utils.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def get_nested_subclasses ( custom_class : Type ) -> List [ Type ]: \"\"\"Recursive utility function to retrieve all nested subclasses of a custom class. Args: custom_class (Type): Custom class from which to recursively retrieve all nested subclasses. Returns: list(Type): A list of custom classes derived from the subclass tree of a custom class. \"\"\" custom_subclasses = custom_class . __subclasses__ () for custom_subclass in custom_subclasses : custom_subclasses . extend ( get_nested_subclasses ( custom_subclass )) return list ( set ( custom_subclasses ))","title":"get_nested_subclasses"}]}