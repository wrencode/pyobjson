{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pyobjson - Python Object JSON Tool \u00b6 Please check out the README to get started!","title":"Introduction"},{"location":"#pyobjson-python-object-json-tool","text":"Please check out the README to get started!","title":"pyobjson - Python Object JSON Tool"},{"location":"deployment/","text":"Deployment \u00b6 Table of Contents \u00b6 Initial Deployment Subsequent Deployment Initial Deployment \u00b6 (Required for initial publication on PyPI as needed) Register a new account on PyPI (do the same for Test PyPI as needed). (Required for initial publication on PyPI) Configure API token authentication for PyPI by creating an API token (do the same for Test PyPI as needed) and copy the value of the API token. (Required for initial publication on PyPI) Create a .env file by running cp .env.template .env in the command line from the project root directory and paste the PyPI API token from the previous step as the value for UV_PUBLISH_TOKEN (this environment variable is used in the Makefile by uv publish to publish the package using uv ). (Optional after initial package publication on PyPI) Configure a new package-specific PyPI API token and update the above UV_PUBLISH_TOKEN environment variable in the .env to use it. (Optional if using Twine) Install twine (if not already installed) with uv add twine . (Optional if using custom domain for GitHub Pages) Follow the steps for managing a custom domain for GitHub Pages . If you want to use a subdomain, you should follow the steps for configuring a subdomain for GitHub Pages , which require the creation of a CNAME DNS record for your custom domain. Note : If you are using CloudFlare and you create a CNAME record for your GitHub Pages subdomain, you must turn off \u201cProxy status\u201d so that it is \u201cDNS only\u201d or else HTTPS will not work! Subsequent Deployment \u00b6 (Optional) Check pyproject.toml for latest dependency versions. (Optional) Update virtual machine with the latest dependencies ( make update in Makefile): uv sync --all-extras --dev Lint code with ruff ( make lint in Makefile): ruff check . Check code security with bandit ( make secure in Makefile): bandit -c pyproject.toml -r . (Optional) Run all pytest tests (see following commands for running subsets of tests) ( make test_code in Makefile): uv run pytest tests (Optional) Run all pytest tests verbosely : uv run pytest -v -s tests (Optional) Run all tests from pytest file: uv run pytest -v -s tests/test_pyobjson.py (Optional) Run specific test from pytest file: uv run pytest -v -s tests/test_pyobjson.py -k test_main (Optional) Test Python support using act for GitHub Actions: act -j build Note : If act is unable to locate Docker, make sure that the required /var/run/docker.sock symlink exists. If it does not, you can fix it by running: sudo ln -s \" $HOME /.docker/run/docker.sock\" /var/run/docker.sock ` Note : If you are running macOS on a devices with an M-series chip (Apple Silicon), you will need to specify linux/amd64 architecture when running act : act --container-architecture linux/amd64 -j build (Optional) Build the PyPI package independent of deployment: make build (Optional) Test packages for PyPI deployment: make verify_build (Optional) Check MkDocs documentation by serving it at http://localhost:8000/ locally: make test_docs (Optional) Build the PyPI package and MkDocs documentation independent of deployment: make docs Note : Running make test_docs from the previous step recreates the documentation without building the PyPI package. Create a git commit: git add . git commit -m 'commit message' Update the git tag with the new version ( git tag -a [tag_name/version] -m [message] ): git tag -a v1.0.0 -m 'release message' git push origin --tags (Optional) Test deployment by building the PyPI packages, recreating the documentation, and deploying to Test PyPI: make uv_test_deploy Deploy the package by building it, recreating the documentation, and deploying the package to PyPI: make uv_deploy Create a second git commit with updated version number and documentation: git add . git commit -m 'updated version number and documentation' Update package git repository: git push","title":"Deployment"},{"location":"deployment/#deployment","text":"","title":"Deployment"},{"location":"deployment/#table-of-contents","text":"Initial Deployment Subsequent Deployment","title":"Table of Contents"},{"location":"deployment/#initial-deployment","text":"(Required for initial publication on PyPI as needed) Register a new account on PyPI (do the same for Test PyPI as needed). (Required for initial publication on PyPI) Configure API token authentication for PyPI by creating an API token (do the same for Test PyPI as needed) and copy the value of the API token. (Required for initial publication on PyPI) Create a .env file by running cp .env.template .env in the command line from the project root directory and paste the PyPI API token from the previous step as the value for UV_PUBLISH_TOKEN (this environment variable is used in the Makefile by uv publish to publish the package using uv ). (Optional after initial package publication on PyPI) Configure a new package-specific PyPI API token and update the above UV_PUBLISH_TOKEN environment variable in the .env to use it. (Optional if using Twine) Install twine (if not already installed) with uv add twine . (Optional if using custom domain for GitHub Pages) Follow the steps for managing a custom domain for GitHub Pages . If you want to use a subdomain, you should follow the steps for configuring a subdomain for GitHub Pages , which require the creation of a CNAME DNS record for your custom domain. Note : If you are using CloudFlare and you create a CNAME record for your GitHub Pages subdomain, you must turn off \u201cProxy status\u201d so that it is \u201cDNS only\u201d or else HTTPS will not work!","title":"Initial Deployment"},{"location":"deployment/#subsequent-deployment","text":"(Optional) Check pyproject.toml for latest dependency versions. (Optional) Update virtual machine with the latest dependencies ( make update in Makefile): uv sync --all-extras --dev Lint code with ruff ( make lint in Makefile): ruff check . Check code security with bandit ( make secure in Makefile): bandit -c pyproject.toml -r . (Optional) Run all pytest tests (see following commands for running subsets of tests) ( make test_code in Makefile): uv run pytest tests (Optional) Run all pytest tests verbosely : uv run pytest -v -s tests (Optional) Run all tests from pytest file: uv run pytest -v -s tests/test_pyobjson.py (Optional) Run specific test from pytest file: uv run pytest -v -s tests/test_pyobjson.py -k test_main (Optional) Test Python support using act for GitHub Actions: act -j build Note : If act is unable to locate Docker, make sure that the required /var/run/docker.sock symlink exists. If it does not, you can fix it by running: sudo ln -s \" $HOME /.docker/run/docker.sock\" /var/run/docker.sock ` Note : If you are running macOS on a devices with an M-series chip (Apple Silicon), you will need to specify linux/amd64 architecture when running act : act --container-architecture linux/amd64 -j build (Optional) Build the PyPI package independent of deployment: make build (Optional) Test packages for PyPI deployment: make verify_build (Optional) Check MkDocs documentation by serving it at http://localhost:8000/ locally: make test_docs (Optional) Build the PyPI package and MkDocs documentation independent of deployment: make docs Note : Running make test_docs from the previous step recreates the documentation without building the PyPI package. Create a git commit: git add . git commit -m 'commit message' Update the git tag with the new version ( git tag -a [tag_name/version] -m [message] ): git tag -a v1.0.0 -m 'release message' git push origin --tags (Optional) Test deployment by building the PyPI packages, recreating the documentation, and deploying to Test PyPI: make uv_test_deploy Deploy the package by building it, recreating the documentation, and deploying the package to PyPI: make uv_deploy Create a second git commit with updated version number and documentation: git add . git commit -m 'updated version number and documentation' Update package git repository: git push","title":"Subsequent Deployment"},{"location":"pyobjson/","text":"pyobjson - Python Object JSON Tool \u00b6 Module containing Python code for the Python Object JSON Tool. Attributes: __author__ ( str ) \u2013 Python package template author. __email__ ( str ) \u2013 Python package template author email. Classes: Name Description PythonObjectJson Base Python Object with JSON serialization and deserialization compatibility. PythonObjectJson \u00b6 Bases: object Base Python Object with JSON serialization and deserialization compatibility. Methods: Name Description __init__ Instantiate the PythonObjectJson class with all keyword arguments. to_json_str Serialize the class object to a JSON string. save_to_json_file Save the class object to a JSON file. load_from_json_file Load the class object from a JSON file. Source code in src/pyobjson/pyobjson.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 class PythonObjectJson ( object ): \"\"\"Base Python Object with JSON serialization and deserialization compatibility.\"\"\" \"\"\"Instantiate the Python Package Template example class. Args: example_init_parameter (str): Example class init parameter for the Python Package Template. Attributes: example_init_parameter (str): Example class attribute for the Python Package Template. \"\"\" def __init__ ( self , ** kwargs ): \"\"\"Instantiate the PythonObjectJson class with all keyword arguments. Args: kwargs (dict): Key/value pairs to be passed to the PythonObjectJson class. \"\"\" vars ( self ) . update ( kwargs ) def __str__ ( self ): return self . to_json_str () def __repr__ ( self ): return self . to_json_str () @staticmethod def _complex_json_handler ( obj : Any ) -> Any : \"\"\"Custom handler to allow custom objects to be serialized into JSON. Args: obj (Any): Custom object to be serialized into JSON. Returns: obj (Any): Serializable version of the custom object. \"\"\" if hasattr ( obj , \"_serialized\" ): # noinspection PyProtectedMember return obj . _serialized () else : try : return str ( obj ) except TypeError : raise TypeError ( f \"Object of type { type ( obj ) } with value of { repr ( obj ) } is not JSON serializable.\" ) def _base_subclasses ( self ) -> Dict [ str , Any ]: \"\"\"Create dict with snakecase keys derived from custom object type camelcase class names. Returns: dict[str, Any]: Dictionary with snakecase strings of all subclasses of PythonObjectJson as keys and subclasses as values. \"\"\" return { cls . __name__ . lower (): cls for cls in self . __class__ . __mro__ [ - 2 ] . __subclasses__ () } def _clean_data_dict ( self ) -> Dict [ str , Any ]: \"\"\"Recursive method to un-type custom class type objects for serialization. Returns: dict[str, Any]: Dictionary that extracts serializable data from custom objects. \"\"\" clean_dict = {} for k , v in vars ( self ) . items (): # noinspection PyProtectedMember clean_dict [ k ] = ( v . _clean_data_dict () if type ( v ) in self . _base_subclasses () . values () else v ) return clean_dict def _serialized ( self ) -> Dict [ str , Any ]: \"\"\"Pack up all object content into nested dictionaries for JSON serialization. Returns: dict[str, Any]: Serializable dictionary. \"\"\" serializable_dict = dict () for att , val in self . _clean_data_dict () . items (): if hasattr ( val , \"_serialized\" ): # noinspection PyProtectedMember serializable_dict [ att ] = val . _serialized () elif isinstance ( val , set ): serializable_dict [ att ] = list ( val ) else : serializable_dict [ att ] = val return { self . __class__ . __name__ . lower (): serializable_dict } def _deserialized ( self , json_data : Any ) -> Any : \"\"\" Args: json_data (Any): JSON data to be deserialized. Returns: obj (Any): Object deserialized from JSON. \"\"\" if isinstance ( json_data , list ): return [ self . _deserialized ( item ) for item in json_data ] elif isinstance ( json_data , dict ): base_subclasses = self . _base_subclasses () # noinspection PyUnboundLocalVariable if ( len ( json_data ) == 1 and ( single_key := next ( iter ( json_data . keys ()))) and single_key in base_subclasses ): # noinspection PyPep8Naming ClassObject = self . _base_subclasses ()[ single_key ] class_args = getfullargspec ( ClassObject . __init__ ) . args [ 1 :] class_attributes : Dict [ str , Any ] = json_data [ single_key ] class_instance = ClassObject ( ** { k : self . _deserialized ( v ) for k , v in class_attributes . items () if k in class_args } ) vars ( class_instance ) . update ( { k : self . _deserialized ( v ) for k , v in class_attributes . items ()} ) return class_instance else : return { k : self . _deserialized ( v ) for k , v in json_data . items ()} else : return json_data def to_json_str ( self ) -> str : \"\"\"Serialize the class object to a JSON string. Returns: str: JSON string derived from the serializable version of the class object. \"\"\" return json . dumps ( self . _serialized (), ensure_ascii = False , indent = 2 , default = self . _complex_json_handler , ) def save_to_json_file ( self , json_file_path : Path ) -> None : \"\"\"Save the class object to a JSON file. Args: json_file_path (Path): Target JSON file path to which the class object will be saved. Returns: None \"\"\" if not json_file_path . exists (): json_file_path . parent . mkdir ( parents = True , exist_ok = True ) with open ( json_file_path , \"w\" , encoding = \"utf-8\" ) as json_file_out : # TODO: fix incorrect file input type warning for json.dump from PyCharm bug https://youtrack.jetbrains.com/issue/PY-73050/openfile.txt-r-return-type-should-be-inferred-as-TextIOWrapper-instead-of-TextIO # noinspection PyTypeChecker json . dump ( self . _serialized (), json_file_out , indent = 2 , default = self . _complex_json_handler , ensure_ascii = False , ) def load_from_json_file ( self , json_file_path : Path ) -> None : \"\"\"Load the class object from a JSON file. Args: json_file_path (Path): Target JSON file path from which the class object will be loaded. Returns: None \"\"\" if not json_file_path . exists (): raise FileNotFoundError ( f \"File { json_file_path } does not exist. Unable to load saved data.\" ) with open ( json_file_path , \"r\" , encoding = \"utf-8\" ) as json_file_in : loaded_class_instance = self . _deserialized ( json . load ( json_file_in )) vars ( self ) . update ( ** vars ( loaded_class_instance )) __init__ \u00b6 __init__ ( ** kwargs ) Instantiate the PythonObjectJson class with all keyword arguments. Parameters: kwargs ( dict , default: {} ) \u2013 Key/value pairs to be passed to the PythonObjectJson class. Source code in src/pyobjson/pyobjson.py 30 31 32 33 34 35 36 37 def __init__ ( self , ** kwargs ): \"\"\"Instantiate the PythonObjectJson class with all keyword arguments. Args: kwargs (dict): Key/value pairs to be passed to the PythonObjectJson class. \"\"\" vars ( self ) . update ( kwargs ) to_json_str \u00b6 to_json_str () Serialize the class object to a JSON string. Returns: str ( str ) \u2013 JSON string derived from the serializable version of the class object. Source code in src/pyobjson/pyobjson.py 158 159 160 161 162 163 164 165 166 167 168 169 170 def to_json_str ( self ) -> str : \"\"\"Serialize the class object to a JSON string. Returns: str: JSON string derived from the serializable version of the class object. \"\"\" return json . dumps ( self . _serialized (), ensure_ascii = False , indent = 2 , default = self . _complex_json_handler , ) save_to_json_file \u00b6 save_to_json_file ( json_file_path ) Save the class object to a JSON file. Parameters: json_file_path ( Path ) \u2013 Target JSON file path to which the class object will be saved. Returns: None \u2013 None Source code in src/pyobjson/pyobjson.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def save_to_json_file ( self , json_file_path : Path ) -> None : \"\"\"Save the class object to a JSON file. Args: json_file_path (Path): Target JSON file path to which the class object will be saved. Returns: None \"\"\" if not json_file_path . exists (): json_file_path . parent . mkdir ( parents = True , exist_ok = True ) with open ( json_file_path , \"w\" , encoding = \"utf-8\" ) as json_file_out : # TODO: fix incorrect file input type warning for json.dump from PyCharm bug https://youtrack.jetbrains.com/issue/PY-73050/openfile.txt-r-return-type-should-be-inferred-as-TextIOWrapper-instead-of-TextIO # noinspection PyTypeChecker json . dump ( self . _serialized (), json_file_out , indent = 2 , default = self . _complex_json_handler , ensure_ascii = False , ) load_from_json_file \u00b6 load_from_json_file ( json_file_path ) Load the class object from a JSON file. Parameters: json_file_path ( Path ) \u2013 Target JSON file path from which the class object will be loaded. Returns: None \u2013 None Source code in src/pyobjson/pyobjson.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 def load_from_json_file ( self , json_file_path : Path ) -> None : \"\"\"Load the class object from a JSON file. Args: json_file_path (Path): Target JSON file path from which the class object will be loaded. Returns: None \"\"\" if not json_file_path . exists (): raise FileNotFoundError ( f \"File { json_file_path } does not exist. Unable to load saved data.\" ) with open ( json_file_path , \"r\" , encoding = \"utf-8\" ) as json_file_in : loaded_class_instance = self . _deserialized ( json . load ( json_file_in )) vars ( self ) . update ( ** vars ( loaded_class_instance ))","title":"pyobjson"},{"location":"pyobjson/#pyobjson-python-object-json-tool","text":"Module containing Python code for the Python Object JSON Tool. Attributes: __author__ ( str ) \u2013 Python package template author. __email__ ( str ) \u2013 Python package template author email. Classes: Name Description PythonObjectJson Base Python Object with JSON serialization and deserialization compatibility.","title":"pyobjson - Python Object JSON Tool"},{"location":"pyobjson/#src.pyobjson.pyobjson.PythonObjectJson","text":"Bases: object Base Python Object with JSON serialization and deserialization compatibility. Methods: Name Description __init__ Instantiate the PythonObjectJson class with all keyword arguments. to_json_str Serialize the class object to a JSON string. save_to_json_file Save the class object to a JSON file. load_from_json_file Load the class object from a JSON file. Source code in src/pyobjson/pyobjson.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 class PythonObjectJson ( object ): \"\"\"Base Python Object with JSON serialization and deserialization compatibility.\"\"\" \"\"\"Instantiate the Python Package Template example class. Args: example_init_parameter (str): Example class init parameter for the Python Package Template. Attributes: example_init_parameter (str): Example class attribute for the Python Package Template. \"\"\" def __init__ ( self , ** kwargs ): \"\"\"Instantiate the PythonObjectJson class with all keyword arguments. Args: kwargs (dict): Key/value pairs to be passed to the PythonObjectJson class. \"\"\" vars ( self ) . update ( kwargs ) def __str__ ( self ): return self . to_json_str () def __repr__ ( self ): return self . to_json_str () @staticmethod def _complex_json_handler ( obj : Any ) -> Any : \"\"\"Custom handler to allow custom objects to be serialized into JSON. Args: obj (Any): Custom object to be serialized into JSON. Returns: obj (Any): Serializable version of the custom object. \"\"\" if hasattr ( obj , \"_serialized\" ): # noinspection PyProtectedMember return obj . _serialized () else : try : return str ( obj ) except TypeError : raise TypeError ( f \"Object of type { type ( obj ) } with value of { repr ( obj ) } is not JSON serializable.\" ) def _base_subclasses ( self ) -> Dict [ str , Any ]: \"\"\"Create dict with snakecase keys derived from custom object type camelcase class names. Returns: dict[str, Any]: Dictionary with snakecase strings of all subclasses of PythonObjectJson as keys and subclasses as values. \"\"\" return { cls . __name__ . lower (): cls for cls in self . __class__ . __mro__ [ - 2 ] . __subclasses__ () } def _clean_data_dict ( self ) -> Dict [ str , Any ]: \"\"\"Recursive method to un-type custom class type objects for serialization. Returns: dict[str, Any]: Dictionary that extracts serializable data from custom objects. \"\"\" clean_dict = {} for k , v in vars ( self ) . items (): # noinspection PyProtectedMember clean_dict [ k ] = ( v . _clean_data_dict () if type ( v ) in self . _base_subclasses () . values () else v ) return clean_dict def _serialized ( self ) -> Dict [ str , Any ]: \"\"\"Pack up all object content into nested dictionaries for JSON serialization. Returns: dict[str, Any]: Serializable dictionary. \"\"\" serializable_dict = dict () for att , val in self . _clean_data_dict () . items (): if hasattr ( val , \"_serialized\" ): # noinspection PyProtectedMember serializable_dict [ att ] = val . _serialized () elif isinstance ( val , set ): serializable_dict [ att ] = list ( val ) else : serializable_dict [ att ] = val return { self . __class__ . __name__ . lower (): serializable_dict } def _deserialized ( self , json_data : Any ) -> Any : \"\"\" Args: json_data (Any): JSON data to be deserialized. Returns: obj (Any): Object deserialized from JSON. \"\"\" if isinstance ( json_data , list ): return [ self . _deserialized ( item ) for item in json_data ] elif isinstance ( json_data , dict ): base_subclasses = self . _base_subclasses () # noinspection PyUnboundLocalVariable if ( len ( json_data ) == 1 and ( single_key := next ( iter ( json_data . keys ()))) and single_key in base_subclasses ): # noinspection PyPep8Naming ClassObject = self . _base_subclasses ()[ single_key ] class_args = getfullargspec ( ClassObject . __init__ ) . args [ 1 :] class_attributes : Dict [ str , Any ] = json_data [ single_key ] class_instance = ClassObject ( ** { k : self . _deserialized ( v ) for k , v in class_attributes . items () if k in class_args } ) vars ( class_instance ) . update ( { k : self . _deserialized ( v ) for k , v in class_attributes . items ()} ) return class_instance else : return { k : self . _deserialized ( v ) for k , v in json_data . items ()} else : return json_data def to_json_str ( self ) -> str : \"\"\"Serialize the class object to a JSON string. Returns: str: JSON string derived from the serializable version of the class object. \"\"\" return json . dumps ( self . _serialized (), ensure_ascii = False , indent = 2 , default = self . _complex_json_handler , ) def save_to_json_file ( self , json_file_path : Path ) -> None : \"\"\"Save the class object to a JSON file. Args: json_file_path (Path): Target JSON file path to which the class object will be saved. Returns: None \"\"\" if not json_file_path . exists (): json_file_path . parent . mkdir ( parents = True , exist_ok = True ) with open ( json_file_path , \"w\" , encoding = \"utf-8\" ) as json_file_out : # TODO: fix incorrect file input type warning for json.dump from PyCharm bug https://youtrack.jetbrains.com/issue/PY-73050/openfile.txt-r-return-type-should-be-inferred-as-TextIOWrapper-instead-of-TextIO # noinspection PyTypeChecker json . dump ( self . _serialized (), json_file_out , indent = 2 , default = self . _complex_json_handler , ensure_ascii = False , ) def load_from_json_file ( self , json_file_path : Path ) -> None : \"\"\"Load the class object from a JSON file. Args: json_file_path (Path): Target JSON file path from which the class object will be loaded. Returns: None \"\"\" if not json_file_path . exists (): raise FileNotFoundError ( f \"File { json_file_path } does not exist. Unable to load saved data.\" ) with open ( json_file_path , \"r\" , encoding = \"utf-8\" ) as json_file_in : loaded_class_instance = self . _deserialized ( json . load ( json_file_in )) vars ( self ) . update ( ** vars ( loaded_class_instance ))","title":"PythonObjectJson"},{"location":"pyobjson/#src.pyobjson.pyobjson.PythonObjectJson.__init__","text":"__init__ ( ** kwargs ) Instantiate the PythonObjectJson class with all keyword arguments. Parameters: kwargs ( dict , default: {} ) \u2013 Key/value pairs to be passed to the PythonObjectJson class. Source code in src/pyobjson/pyobjson.py 30 31 32 33 34 35 36 37 def __init__ ( self , ** kwargs ): \"\"\"Instantiate the PythonObjectJson class with all keyword arguments. Args: kwargs (dict): Key/value pairs to be passed to the PythonObjectJson class. \"\"\" vars ( self ) . update ( kwargs )","title":"__init__"},{"location":"pyobjson/#src.pyobjson.pyobjson.PythonObjectJson.to_json_str","text":"to_json_str () Serialize the class object to a JSON string. Returns: str ( str ) \u2013 JSON string derived from the serializable version of the class object. Source code in src/pyobjson/pyobjson.py 158 159 160 161 162 163 164 165 166 167 168 169 170 def to_json_str ( self ) -> str : \"\"\"Serialize the class object to a JSON string. Returns: str: JSON string derived from the serializable version of the class object. \"\"\" return json . dumps ( self . _serialized (), ensure_ascii = False , indent = 2 , default = self . _complex_json_handler , )","title":"to_json_str"},{"location":"pyobjson/#src.pyobjson.pyobjson.PythonObjectJson.save_to_json_file","text":"save_to_json_file ( json_file_path ) Save the class object to a JSON file. Parameters: json_file_path ( Path ) \u2013 Target JSON file path to which the class object will be saved. Returns: None \u2013 None Source code in src/pyobjson/pyobjson.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def save_to_json_file ( self , json_file_path : Path ) -> None : \"\"\"Save the class object to a JSON file. Args: json_file_path (Path): Target JSON file path to which the class object will be saved. Returns: None \"\"\" if not json_file_path . exists (): json_file_path . parent . mkdir ( parents = True , exist_ok = True ) with open ( json_file_path , \"w\" , encoding = \"utf-8\" ) as json_file_out : # TODO: fix incorrect file input type warning for json.dump from PyCharm bug https://youtrack.jetbrains.com/issue/PY-73050/openfile.txt-r-return-type-should-be-inferred-as-TextIOWrapper-instead-of-TextIO # noinspection PyTypeChecker json . dump ( self . _serialized (), json_file_out , indent = 2 , default = self . _complex_json_handler , ensure_ascii = False , )","title":"save_to_json_file"},{"location":"pyobjson/#src.pyobjson.pyobjson.PythonObjectJson.load_from_json_file","text":"load_from_json_file ( json_file_path ) Load the class object from a JSON file. Parameters: json_file_path ( Path ) \u2013 Target JSON file path from which the class object will be loaded. Returns: None \u2013 None Source code in src/pyobjson/pyobjson.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 def load_from_json_file ( self , json_file_path : Path ) -> None : \"\"\"Load the class object from a JSON file. Args: json_file_path (Path): Target JSON file path from which the class object will be loaded. Returns: None \"\"\" if not json_file_path . exists (): raise FileNotFoundError ( f \"File { json_file_path } does not exist. Unable to load saved data.\" ) with open ( json_file_path , \"r\" , encoding = \"utf-8\" ) as json_file_in : loaded_class_instance = self . _deserialized ( json . load ( json_file_in )) vars ( self ) . update ( ** vars ( loaded_class_instance ))","title":"load_from_json_file"},{"location":"readme/","text":"pyobjson - Python Object JSON Tool \u00b6 Utility library for serializing/deserializing custom Python objects to/from JSON. Do you like the Python Object JSON Tool? Star the repository on GitHub and please consider helping support its ongoing development: READ THE DOCS HERE! Detailed documentation can be found at https://pyobjson.wrencode.dev . Table of Contents \u00b6 About Dependencies Toolchain Usage About \u00b6 The Python Object JSON Tool is a utility library for serializing/deserializing custom Python objects to/from JSON. Dependencies \u00b6 The Python Object JSON Tool does not have any third-party dependencies to run the code. It has several development dependencies, which can be seen in the package pyproject.toml . Toolchain \u00b6 The below tools and resources are used as part of pyobjson: uv - package management ruff - code linting bandit - code security make - Makefile build automation MkDocs - package documentation python-dotenv - programmatic access to environment variables defined in a .env file pytest - code testing framework GitHub Actions - CI/CD act - GitHub Actions testing Usage \u00b6 COMING SOON!","title":"README"},{"location":"readme/#pyobjson-python-object-json-tool","text":"Utility library for serializing/deserializing custom Python objects to/from JSON. Do you like the Python Object JSON Tool? Star the repository on GitHub and please consider helping support its ongoing development: READ THE DOCS HERE! Detailed documentation can be found at https://pyobjson.wrencode.dev .","title":"pyobjson - Python Object JSON Tool"},{"location":"readme/#table-of-contents","text":"About Dependencies Toolchain Usage","title":"Table of Contents"},{"location":"readme/#about","text":"The Python Object JSON Tool is a utility library for serializing/deserializing custom Python objects to/from JSON.","title":"About"},{"location":"readme/#dependencies","text":"The Python Object JSON Tool does not have any third-party dependencies to run the code. It has several development dependencies, which can be seen in the package pyproject.toml .","title":"Dependencies"},{"location":"readme/#toolchain","text":"The below tools and resources are used as part of pyobjson: uv - package management ruff - code linting bandit - code security make - Makefile build automation MkDocs - package documentation python-dotenv - programmatic access to environment variables defined in a .env file pytest - code testing framework GitHub Actions - CI/CD act - GitHub Actions testing","title":"Toolchain"},{"location":"readme/#usage","text":"COMING SOON!","title":"Usage"},{"location":"tests/","text":"PyTest \u00b6 Modules: Name Description conftest Pytest top-level conftest.py. test_pyobjson Pytest test for Python Object JSON Tool code. conftest \u00b6 Pytest top-level conftest.py. Functions: Name Description python_object_json_class Provide PythonObjectJson class for testing. python_object_json_class \u00b6 python_object_json_class () Provide PythonObjectJson class for testing. Returns: Type [ PythonObjectJson ] \u2013 Type[PythonObjectJson]: PythonObjectJson class. Source code in tests/conftest.py 14 15 16 17 18 19 20 21 22 @pytest . fixture ( scope = \"module\" ) def python_object_json_class () -> Type [ PythonObjectJson ]: \"\"\"Provide PythonObjectJson class for testing. Returns: Type[PythonObjectJson]: PythonObjectJson class. \"\"\" return PythonObjectJson test_pyobjson \u00b6 Pytest test for Python Object JSON Tool code. Note Tests pyobjson.py module.","title":"PyTest"},{"location":"tests/#pytest","text":"Modules: Name Description conftest Pytest top-level conftest.py. test_pyobjson Pytest test for Python Object JSON Tool code.","title":"PyTest"},{"location":"tests/#tests.conftest","text":"Pytest top-level conftest.py. Functions: Name Description python_object_json_class Provide PythonObjectJson class for testing.","title":"conftest"},{"location":"tests/#tests.conftest.python_object_json_class","text":"python_object_json_class () Provide PythonObjectJson class for testing. Returns: Type [ PythonObjectJson ] \u2013 Type[PythonObjectJson]: PythonObjectJson class. Source code in tests/conftest.py 14 15 16 17 18 19 20 21 22 @pytest . fixture ( scope = \"module\" ) def python_object_json_class () -> Type [ PythonObjectJson ]: \"\"\"Provide PythonObjectJson class for testing. Returns: Type[PythonObjectJson]: PythonObjectJson class. \"\"\" return PythonObjectJson","title":"python_object_json_class"},{"location":"tests/#tests.test_pyobjson","text":"Pytest test for Python Object JSON Tool code. Note Tests pyobjson.py module.","title":"test_pyobjson"}]}