{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pyobjson - Python Object JSON Tool \u00b6 Please check out the README to get started!","title":"Introduction"},{"location":"#pyobjson-python-object-json-tool","text":"Please check out the README to get started!","title":"pyobjson - Python Object JSON Tool"},{"location":"base/","text":"pyobjson - Python Object JSON Tool \u00b6 Python Object JSON Tool pyobjson.base module. Attributes: __author__ ( str ) \u2013 Python package template author. __email__ ( str ) \u2013 Python package template author email. Classes: Name Description PythonObjectJson Base Python Object with JSON serialization and deserialization compatibility. PythonObjectJson \u00b6 Bases: object Base Python Object with JSON serialization and deserialization compatibility. Methods: Name Description __init__ Instantiate the PythonObjectJson class with all keyword arguments. serialize Create a serializable dictionary from the class instance. to_json_str Serialize the class instance to a JSON string. from_json_str Load the class instance from a JSON string. save_to_json_file Save the class instance to a JSON file. load_from_json_file Load the class instance from a JSON file. Source code in src/pyobjson/base.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 class PythonObjectJson ( object ): \"\"\"Base Python Object with JSON serialization and deserialization compatibility.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Instantiate the PythonObjectJson class with all keyword arguments. Args: kwargs (dict): Key/value pairs to be passed to the PythonObjectJson class. \"\"\" vars ( self ) . update ( kwargs ) def __str__ ( self ): return self . to_json_str () def __repr__ ( self ): return ( f \" { derive_custom_object_key ( self . __class__ , as_lower = False ) } \" f \"( { ',' . join ([ f ' { k } = { v } ' for k , v in vars ( self ) . items ()]) } )\" ) def __eq__ ( self , other ): return type ( self ) is type ( other ) and vars ( self ) == vars ( other ) def _base_subclasses ( self ) -> Dict [ str , Type ]: \"\"\"Create a dictionary with snakecase keys derived from custom object type camelcase class names. Returns: dict[str, Type]: Dictionary with snakecase strings of all subclasses of PythonObjectJson as keys and subclasses as values. \"\"\" # retrieve all class subclasses after base class return { derive_custom_object_key ( cls ): cls for cls in self . __class__ . __mro__ [ - 2 ] . __subclasses__ ()} def serialize ( self ) -> Dict [ str , Any ]: \"\"\"Create a serializable dictionary from the class instance. Returns: dict[str, Any]: Serializable dictionary representing the class instance. \"\"\" return serialize ( self , list ( self . _base_subclasses () . values ())) def to_json_str ( self ) -> str : \"\"\"Serialize the class instance to a JSON string. Returns: str: JSON string derived from the serializable version of the class instance. \"\"\" return json . dumps ( self . serialize (), ensure_ascii = False , indent = 2 ) def from_json_str ( self , json_str : str ) -> None : \"\"\"Load the class instance from a JSON string. Args: json_str (str): JSON string to be deserialized into the class instance. Returns: None \"\"\" loaded_class_instance = deserialize ( json . loads ( json_str ), self . _base_subclasses ()) # update the class instance attributes with the attributes from the loaded class instance vars ( self ) . update ( ** vars ( loaded_class_instance )) def save_to_json_file ( self , json_file_path : Path ) -> None : \"\"\"Save the class instance to a JSON file. Args: json_file_path (Path): Target JSON file path to which the class instance will be saved. Returns: None \"\"\" if not json_file_path . exists (): json_file_path . parent . mkdir ( parents = True , exist_ok = True ) with open ( json_file_path , \"w\" , encoding = \"utf-8\" ) as json_file_out : # TODO: fix incorrect file input type warning for json.dump from PyCharm bug https://youtrack.jetbrains.com/issue/PY-73050/openfile.txt-r-return-type-should-be-inferred-as-TextIOWrapper-instead-of-TextIO # noinspection PyTypeChecker json . dump ( self . serialize (), json_file_out , ensure_ascii = False , indent = 2 ) def load_from_json_file ( self , json_file_path : Path ) -> None : \"\"\"Load the class instance from a JSON file. Args: json_file_path (Path): Target JSON file path from which the class instance will be loaded. Returns: None \"\"\" if not json_file_path . exists (): raise FileNotFoundError ( f \"File { json_file_path } does not exist. Unable to load saved data.\" ) with open ( json_file_path , \"r\" , encoding = \"utf-8\" ) as json_file_in : loaded_class_instance = deserialize ( json . load ( json_file_in ), self . _base_subclasses ()) vars ( self ) . update ( ** vars ( loaded_class_instance )) __init__ \u00b6 __init__ ( ** kwargs ) Instantiate the PythonObjectJson class with all keyword arguments. Parameters: kwargs ( dict , default: {} ) \u2013 Key/value pairs to be passed to the PythonObjectJson class. Source code in src/pyobjson/base.py 23 24 25 26 27 28 29 30 def __init__ ( self , ** kwargs ): \"\"\"Instantiate the PythonObjectJson class with all keyword arguments. Args: kwargs (dict): Key/value pairs to be passed to the PythonObjectJson class. \"\"\" vars ( self ) . update ( kwargs ) serialize \u00b6 serialize () Create a serializable dictionary from the class instance. Returns: Dict [ str , Any ] \u2013 dict[str, Any]: Serializable dictionary representing the class instance. Source code in src/pyobjson/base.py 55 56 57 58 59 60 61 62 def serialize ( self ) -> Dict [ str , Any ]: \"\"\"Create a serializable dictionary from the class instance. Returns: dict[str, Any]: Serializable dictionary representing the class instance. \"\"\" return serialize ( self , list ( self . _base_subclasses () . values ())) to_json_str \u00b6 to_json_str () Serialize the class instance to a JSON string. Returns: str ( str ) \u2013 JSON string derived from the serializable version of the class instance. Source code in src/pyobjson/base.py 64 65 66 67 68 69 70 71 def to_json_str ( self ) -> str : \"\"\"Serialize the class instance to a JSON string. Returns: str: JSON string derived from the serializable version of the class instance. \"\"\" return json . dumps ( self . serialize (), ensure_ascii = False , indent = 2 ) from_json_str \u00b6 from_json_str ( json_str ) Load the class instance from a JSON string. Parameters: json_str ( str ) \u2013 JSON string to be deserialized into the class instance. Returns: None \u2013 None Source code in src/pyobjson/base.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def from_json_str ( self , json_str : str ) -> None : \"\"\"Load the class instance from a JSON string. Args: json_str (str): JSON string to be deserialized into the class instance. Returns: None \"\"\" loaded_class_instance = deserialize ( json . loads ( json_str ), self . _base_subclasses ()) # update the class instance attributes with the attributes from the loaded class instance vars ( self ) . update ( ** vars ( loaded_class_instance )) save_to_json_file \u00b6 save_to_json_file ( json_file_path ) Save the class instance to a JSON file. Parameters: json_file_path ( Path ) \u2013 Target JSON file path to which the class instance will be saved. Returns: None \u2013 None Source code in src/pyobjson/base.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def save_to_json_file ( self , json_file_path : Path ) -> None : \"\"\"Save the class instance to a JSON file. Args: json_file_path (Path): Target JSON file path to which the class instance will be saved. Returns: None \"\"\" if not json_file_path . exists (): json_file_path . parent . mkdir ( parents = True , exist_ok = True ) with open ( json_file_path , \"w\" , encoding = \"utf-8\" ) as json_file_out : # TODO: fix incorrect file input type warning for json.dump from PyCharm bug https://youtrack.jetbrains.com/issue/PY-73050/openfile.txt-r-return-type-should-be-inferred-as-TextIOWrapper-instead-of-TextIO # noinspection PyTypeChecker json . dump ( self . serialize (), json_file_out , ensure_ascii = False , indent = 2 ) load_from_json_file \u00b6 load_from_json_file ( json_file_path ) Load the class instance from a JSON file. Parameters: json_file_path ( Path ) \u2013 Target JSON file path from which the class instance will be loaded. Returns: None \u2013 None Source code in src/pyobjson/base.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def load_from_json_file ( self , json_file_path : Path ) -> None : \"\"\"Load the class instance from a JSON file. Args: json_file_path (Path): Target JSON file path from which the class instance will be loaded. Returns: None \"\"\" if not json_file_path . exists (): raise FileNotFoundError ( f \"File { json_file_path } does not exist. Unable to load saved data.\" ) with open ( json_file_path , \"r\" , encoding = \"utf-8\" ) as json_file_in : loaded_class_instance = deserialize ( json . load ( json_file_in ), self . _base_subclasses ()) vars ( self ) . update ( ** vars ( loaded_class_instance ))","title":"pyobjson"},{"location":"base/#pyobjson-python-object-json-tool","text":"Python Object JSON Tool pyobjson.base module. Attributes: __author__ ( str ) \u2013 Python package template author. __email__ ( str ) \u2013 Python package template author email. Classes: Name Description PythonObjectJson Base Python Object with JSON serialization and deserialization compatibility.","title":"pyobjson - Python Object JSON Tool"},{"location":"base/#src.pyobjson.base.PythonObjectJson","text":"Bases: object Base Python Object with JSON serialization and deserialization compatibility. Methods: Name Description __init__ Instantiate the PythonObjectJson class with all keyword arguments. serialize Create a serializable dictionary from the class instance. to_json_str Serialize the class instance to a JSON string. from_json_str Load the class instance from a JSON string. save_to_json_file Save the class instance to a JSON file. load_from_json_file Load the class instance from a JSON file. Source code in src/pyobjson/base.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 class PythonObjectJson ( object ): \"\"\"Base Python Object with JSON serialization and deserialization compatibility.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Instantiate the PythonObjectJson class with all keyword arguments. Args: kwargs (dict): Key/value pairs to be passed to the PythonObjectJson class. \"\"\" vars ( self ) . update ( kwargs ) def __str__ ( self ): return self . to_json_str () def __repr__ ( self ): return ( f \" { derive_custom_object_key ( self . __class__ , as_lower = False ) } \" f \"( { ',' . join ([ f ' { k } = { v } ' for k , v in vars ( self ) . items ()]) } )\" ) def __eq__ ( self , other ): return type ( self ) is type ( other ) and vars ( self ) == vars ( other ) def _base_subclasses ( self ) -> Dict [ str , Type ]: \"\"\"Create a dictionary with snakecase keys derived from custom object type camelcase class names. Returns: dict[str, Type]: Dictionary with snakecase strings of all subclasses of PythonObjectJson as keys and subclasses as values. \"\"\" # retrieve all class subclasses after base class return { derive_custom_object_key ( cls ): cls for cls in self . __class__ . __mro__ [ - 2 ] . __subclasses__ ()} def serialize ( self ) -> Dict [ str , Any ]: \"\"\"Create a serializable dictionary from the class instance. Returns: dict[str, Any]: Serializable dictionary representing the class instance. \"\"\" return serialize ( self , list ( self . _base_subclasses () . values ())) def to_json_str ( self ) -> str : \"\"\"Serialize the class instance to a JSON string. Returns: str: JSON string derived from the serializable version of the class instance. \"\"\" return json . dumps ( self . serialize (), ensure_ascii = False , indent = 2 ) def from_json_str ( self , json_str : str ) -> None : \"\"\"Load the class instance from a JSON string. Args: json_str (str): JSON string to be deserialized into the class instance. Returns: None \"\"\" loaded_class_instance = deserialize ( json . loads ( json_str ), self . _base_subclasses ()) # update the class instance attributes with the attributes from the loaded class instance vars ( self ) . update ( ** vars ( loaded_class_instance )) def save_to_json_file ( self , json_file_path : Path ) -> None : \"\"\"Save the class instance to a JSON file. Args: json_file_path (Path): Target JSON file path to which the class instance will be saved. Returns: None \"\"\" if not json_file_path . exists (): json_file_path . parent . mkdir ( parents = True , exist_ok = True ) with open ( json_file_path , \"w\" , encoding = \"utf-8\" ) as json_file_out : # TODO: fix incorrect file input type warning for json.dump from PyCharm bug https://youtrack.jetbrains.com/issue/PY-73050/openfile.txt-r-return-type-should-be-inferred-as-TextIOWrapper-instead-of-TextIO # noinspection PyTypeChecker json . dump ( self . serialize (), json_file_out , ensure_ascii = False , indent = 2 ) def load_from_json_file ( self , json_file_path : Path ) -> None : \"\"\"Load the class instance from a JSON file. Args: json_file_path (Path): Target JSON file path from which the class instance will be loaded. Returns: None \"\"\" if not json_file_path . exists (): raise FileNotFoundError ( f \"File { json_file_path } does not exist. Unable to load saved data.\" ) with open ( json_file_path , \"r\" , encoding = \"utf-8\" ) as json_file_in : loaded_class_instance = deserialize ( json . load ( json_file_in ), self . _base_subclasses ()) vars ( self ) . update ( ** vars ( loaded_class_instance ))","title":"PythonObjectJson"},{"location":"base/#src.pyobjson.base.PythonObjectJson.__init__","text":"__init__ ( ** kwargs ) Instantiate the PythonObjectJson class with all keyword arguments. Parameters: kwargs ( dict , default: {} ) \u2013 Key/value pairs to be passed to the PythonObjectJson class. Source code in src/pyobjson/base.py 23 24 25 26 27 28 29 30 def __init__ ( self , ** kwargs ): \"\"\"Instantiate the PythonObjectJson class with all keyword arguments. Args: kwargs (dict): Key/value pairs to be passed to the PythonObjectJson class. \"\"\" vars ( self ) . update ( kwargs )","title":"__init__"},{"location":"base/#src.pyobjson.base.PythonObjectJson.serialize","text":"serialize () Create a serializable dictionary from the class instance. Returns: Dict [ str , Any ] \u2013 dict[str, Any]: Serializable dictionary representing the class instance. Source code in src/pyobjson/base.py 55 56 57 58 59 60 61 62 def serialize ( self ) -> Dict [ str , Any ]: \"\"\"Create a serializable dictionary from the class instance. Returns: dict[str, Any]: Serializable dictionary representing the class instance. \"\"\" return serialize ( self , list ( self . _base_subclasses () . values ()))","title":"serialize"},{"location":"base/#src.pyobjson.base.PythonObjectJson.to_json_str","text":"to_json_str () Serialize the class instance to a JSON string. Returns: str ( str ) \u2013 JSON string derived from the serializable version of the class instance. Source code in src/pyobjson/base.py 64 65 66 67 68 69 70 71 def to_json_str ( self ) -> str : \"\"\"Serialize the class instance to a JSON string. Returns: str: JSON string derived from the serializable version of the class instance. \"\"\" return json . dumps ( self . serialize (), ensure_ascii = False , indent = 2 )","title":"to_json_str"},{"location":"base/#src.pyobjson.base.PythonObjectJson.from_json_str","text":"from_json_str ( json_str ) Load the class instance from a JSON string. Parameters: json_str ( str ) \u2013 JSON string to be deserialized into the class instance. Returns: None \u2013 None Source code in src/pyobjson/base.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def from_json_str ( self , json_str : str ) -> None : \"\"\"Load the class instance from a JSON string. Args: json_str (str): JSON string to be deserialized into the class instance. Returns: None \"\"\" loaded_class_instance = deserialize ( json . loads ( json_str ), self . _base_subclasses ()) # update the class instance attributes with the attributes from the loaded class instance vars ( self ) . update ( ** vars ( loaded_class_instance ))","title":"from_json_str"},{"location":"base/#src.pyobjson.base.PythonObjectJson.save_to_json_file","text":"save_to_json_file ( json_file_path ) Save the class instance to a JSON file. Parameters: json_file_path ( Path ) \u2013 Target JSON file path to which the class instance will be saved. Returns: None \u2013 None Source code in src/pyobjson/base.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def save_to_json_file ( self , json_file_path : Path ) -> None : \"\"\"Save the class instance to a JSON file. Args: json_file_path (Path): Target JSON file path to which the class instance will be saved. Returns: None \"\"\" if not json_file_path . exists (): json_file_path . parent . mkdir ( parents = True , exist_ok = True ) with open ( json_file_path , \"w\" , encoding = \"utf-8\" ) as json_file_out : # TODO: fix incorrect file input type warning for json.dump from PyCharm bug https://youtrack.jetbrains.com/issue/PY-73050/openfile.txt-r-return-type-should-be-inferred-as-TextIOWrapper-instead-of-TextIO # noinspection PyTypeChecker json . dump ( self . serialize (), json_file_out , ensure_ascii = False , indent = 2 )","title":"save_to_json_file"},{"location":"base/#src.pyobjson.base.PythonObjectJson.load_from_json_file","text":"load_from_json_file ( json_file_path ) Load the class instance from a JSON file. Parameters: json_file_path ( Path ) \u2013 Target JSON file path from which the class instance will be loaded. Returns: None \u2013 None Source code in src/pyobjson/base.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def load_from_json_file ( self , json_file_path : Path ) -> None : \"\"\"Load the class instance from a JSON file. Args: json_file_path (Path): Target JSON file path from which the class instance will be loaded. Returns: None \"\"\" if not json_file_path . exists (): raise FileNotFoundError ( f \"File { json_file_path } does not exist. Unable to load saved data.\" ) with open ( json_file_path , \"r\" , encoding = \"utf-8\" ) as json_file_in : loaded_class_instance = deserialize ( json . load ( json_file_in ), self . _base_subclasses ()) vars ( self ) . update ( ** vars ( loaded_class_instance ))","title":"load_from_json_file"},{"location":"data/","text":"Data Tools \u00b6 Python Object JSON Tool pyobjson.json module. Attributes: __author__ ( str ) \u2013 Python package template author. __email__ ( str ) \u2013 Python package template author email. Functions: Name Description unpack_custom_class_vars Recursive function to un-type custom class type objects for serialization. extract_typed_key_value_pairs Function to extract both keys and Python object types from specially formatted dictionary keys and make serialize Recursive function to serialize custom Python objects into nested dictionaries for conversion to JSON. deserialize Recursive function to deserialize JSON into typed data structures for conversion to custom Python objects. unpack_custom_class_vars \u00b6 unpack_custom_class_vars ( custom_class_instance , pyobjson_base_custom_subclasses ) Recursive function to un-type custom class type objects for serialization. Parameters: custom_class_instance ( Any ) \u2013 Custom Python class instance to be serialized. pyobjson_base_custom_subclasses ( list [ Type ] ) \u2013 List of custom Python class subclasses. Returns: Dict [ str , Any ] \u2013 dict[str, Any]: Dictionary that extracts serializable data from custom objects. Source code in src/pyobjson/data.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def unpack_custom_class_vars ( custom_class_instance : Any , pyobjson_base_custom_subclasses : List [ Type ]) -> Dict [ str , Any ]: \"\"\"Recursive function to un-type custom class type objects for serialization. Args: custom_class_instance (Any): Custom Python class instance to be serialized. pyobjson_base_custom_subclasses (list[Type]): List of custom Python class subclasses. Returns: dict[str, Any]: Dictionary that extracts serializable data from custom objects. \"\"\" unpacked = {} for k , v in vars ( custom_class_instance ) . items (): unpacked [ k ] = ( unpack_custom_class_vars ( v , pyobjson_base_custom_subclasses ) if type ( v ) in pyobjson_base_custom_subclasses else v ) return unpacked extract_typed_key_value_pairs \u00b6 extract_typed_key_value_pairs ( json_dict ) Function to extract both keys and Python object types from specially formatted dictionary keys and make their respective values into Python objects of those types. Parameters: json_dict ( Dict [ str , Any ] ) \u2013 JSON dictionary that may contain keys in the format type.key_name (e.g. path.root_directory) with corresponding string values representing Python objects of that type. Returns: Dict [ str , Any ] \u2013 dict[str, Any]: Dictionary with both keys and Python object values derived from specially formatted JSON dictionary keys. Source code in src/pyobjson/data.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 def extract_typed_key_value_pairs ( json_dict : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\"Function to extract both keys and Python object types from specially formatted dictionary keys and make their respective values into Python objects of those types. Args: json_dict (Dict[str, Any]): JSON dictionary that may contain keys in the format type.key_name (e.g. path.root_directory) with corresponding string values representing Python objects of that type. Returns: dict[str, Any]: Dictionary with both keys and Python object values derived from specially formatted JSON dictionary keys. \"\"\" derived_key_value_pairs = {} for key , value in json_dict . items (): # check if key is formatted with a single \".\" to indicate a value type if key . count ( \".\" ) == 1 : type_name , key = key . split ( \".\" ) type_category = None if type_name . count ( \":\" ) == 1 : type_category , type_name = type_name . split ( \":\" ) if type_category == \"collection\" : if type_name == \"dict\" : # do nothing because JSON supports dictionaries pass elif type_name == \"list\" : # do nothing because JSON supports lists pass elif type_name == \"set\" : value = set ( value ) elif type_name == \"tuple\" : value = tuple ( value ) elif type_name == \"bytes\" or type_name == \"bytearray\" : value = b64decode ( value ) elif type_name == \"path\" : # handle posix paths value = Path ( value ) elif type_name == \"callable\" : # handle callables (functions, methods, etc.) # extract the callable components from a value with format module.callable::arg1:type1,arg2:type2 callable_path , callable_args = value . split ( \"::\" , 1 ) # extract the callable module and name module , callable_name = callable_path . rsplit ( \".\" , 1 ) # use the callable module and name to import the callable itself and set it to the value value = getattr ( import_module ( module ), callable_name ) elif type_name == \"datetime\" : # handle datetime objects value = datetime . fromisoformat ( value ) else : raise ValueError ( f \"JSON data ( { key } : { value } ) is not compatible with pyobjson.\" ) derived_key_value_pairs [ key ] = value else : # add key-value pair without modification if key is not formatted with a single \".\" to indicate a value type derived_key_value_pairs [ key ] = value return derived_key_value_pairs serialize \u00b6 serialize ( obj , pyobjson_base_custom_subclasses ) Recursive function to serialize custom Python objects into nested dictionaries for conversion to JSON. Parameters: obj ( Any ) \u2013 Python object to serialize. pyobjson_base_custom_subclasses ( list [ Type ] ) \u2013 List of custom Python class subclasses. Returns: Any \u2013 dict[str, Any]: Serializable dictionary. Source code in src/pyobjson/data.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def serialize ( obj : Any , pyobjson_base_custom_subclasses : List [ Type ]) -> Any : \"\"\"Recursive function to serialize custom Python objects into nested dictionaries for conversion to JSON. Args: obj (Any): Python object to serialize. pyobjson_base_custom_subclasses (list[Type]): List of custom Python class subclasses. Returns: dict[str, Any]: Serializable dictionary. \"\"\" if type ( obj ) in pyobjson_base_custom_subclasses : serializable_obj = {} for att , val in unpack_custom_class_vars ( obj , pyobjson_base_custom_subclasses ) . items (): if isinstance ( val , dict ): att = f \"collection:dict. { att } \" elif isinstance ( val , ( list , set , tuple , bytes , bytearray )): att = f \"collection: { derive_custom_object_key ( val . __class__ ) } . { att } \" elif isinstance ( val , Path ): att = f \"path. { att } \" elif isinstance ( val , Callable ): att = f \"callable. { att } \" elif isinstance ( val , datetime ): att = f \"datetime. { att } \" serializable_obj [ att ] = serialize ( val , pyobjson_base_custom_subclasses ) return { derive_custom_object_key ( obj . __class__ ): serializable_obj } elif isinstance ( obj , dict ): return { k : serialize ( v , pyobjson_base_custom_subclasses ) for k , v in obj . items ()} elif isinstance ( obj , ( list , set , tuple )): return [ serialize ( v , pyobjson_base_custom_subclasses ) for v in obj ] elif isinstance ( obj , ( bytes , bytearray )): return b64encode ( obj ) . decode ( \"utf-8\" ) elif isinstance ( obj , Path ): return str ( obj ) elif isinstance ( obj , Callable ): return derive_custom_callable_value ( obj ) elif isinstance ( obj , datetime ): return obj . isoformat () else : return obj deserialize \u00b6 deserialize ( json_data , pyobjson_base_custom_subclasses_by_key ) Recursive function to deserialize JSON into typed data structures for conversion to custom Python objects. Parameters: json_data ( Any ) \u2013 JSON data to be deserialized. pyobjson_base_custom_subclasses_by_key ( dict [ str , Type ] ) \u2013 Dictionary with snakecase strings of all subclasses of PythonObjectJson as keys and subclasses as values. Returns: obj ( Any ) \u2013 Object deserialized from JSON. Source code in src/pyobjson/data.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def deserialize ( json_data : Any , pyobjson_base_custom_subclasses_by_key : Dict [ str , Type ]) -> Any : \"\"\"Recursive function to deserialize JSON into typed data structures for conversion to custom Python objects. Args: json_data (Any): JSON data to be deserialized. pyobjson_base_custom_subclasses_by_key (dict[str, Type]): Dictionary with snakecase strings of all subclasses of PythonObjectJson as keys and subclasses as values. Returns: obj (Any): Object deserialized from JSON. \"\"\" base_subclasses : Dict [ str , Type ] = pyobjson_base_custom_subclasses_by_key if isinstance ( json_data , list ): # recursively deserialize all elements if json_data is a list return [ deserialize ( item , base_subclasses ) for item in json_data ] elif isinstance ( json_data , dict ): # recursively deserialize all values if json_data is a dictionary # noinspection PyUnboundLocalVariable if len ( json_data ) == 1 and ( single_key := next ( iter ( json_data . keys ()))) and single_key in base_subclasses : # check if json_data is a dict with only one key that matches a custom subclass for object derivation # noinspection PyPep8Naming ClassObject = base_subclasses [ single_key ] # retrieve custom subclass class_args = getfullargspec ( ClassObject . __init__ ) . args [ 1 :] # get __init__ arguments for custom subclass class_instance_attributes : Dict [ str , Any ] = json_data [ single_key ] # get JSON to be deserialized # create an instance of the custom subclass using the __init__ arguments class_instance = ClassObject ( ** { k : deserialize ( v , base_subclasses ) for k , v in extract_typed_key_value_pairs ( class_instance_attributes ) . items () if k in class_args } ) # assign the remaining class attributes to the created class instance vars ( class_instance ) . update ({ k : deserialize ( v , base_subclasses ) for k , v in extract_typed_key_value_pairs ( class_instance_attributes ) . items () }) return class_instance else : return { k : deserialize ( v , base_subclasses ) for k , v in extract_typed_key_value_pairs ( json_data ) . items ()} else : return json_data","title":"Data Tools"},{"location":"data/#data-tools","text":"Python Object JSON Tool pyobjson.json module. Attributes: __author__ ( str ) \u2013 Python package template author. __email__ ( str ) \u2013 Python package template author email. Functions: Name Description unpack_custom_class_vars Recursive function to un-type custom class type objects for serialization. extract_typed_key_value_pairs Function to extract both keys and Python object types from specially formatted dictionary keys and make serialize Recursive function to serialize custom Python objects into nested dictionaries for conversion to JSON. deserialize Recursive function to deserialize JSON into typed data structures for conversion to custom Python objects.","title":"Data Tools"},{"location":"data/#src.pyobjson.data.unpack_custom_class_vars","text":"unpack_custom_class_vars ( custom_class_instance , pyobjson_base_custom_subclasses ) Recursive function to un-type custom class type objects for serialization. Parameters: custom_class_instance ( Any ) \u2013 Custom Python class instance to be serialized. pyobjson_base_custom_subclasses ( list [ Type ] ) \u2013 List of custom Python class subclasses. Returns: Dict [ str , Any ] \u2013 dict[str, Any]: Dictionary that extracts serializable data from custom objects. Source code in src/pyobjson/data.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def unpack_custom_class_vars ( custom_class_instance : Any , pyobjson_base_custom_subclasses : List [ Type ]) -> Dict [ str , Any ]: \"\"\"Recursive function to un-type custom class type objects for serialization. Args: custom_class_instance (Any): Custom Python class instance to be serialized. pyobjson_base_custom_subclasses (list[Type]): List of custom Python class subclasses. Returns: dict[str, Any]: Dictionary that extracts serializable data from custom objects. \"\"\" unpacked = {} for k , v in vars ( custom_class_instance ) . items (): unpacked [ k ] = ( unpack_custom_class_vars ( v , pyobjson_base_custom_subclasses ) if type ( v ) in pyobjson_base_custom_subclasses else v ) return unpacked","title":"unpack_custom_class_vars"},{"location":"data/#src.pyobjson.data.extract_typed_key_value_pairs","text":"extract_typed_key_value_pairs ( json_dict ) Function to extract both keys and Python object types from specially formatted dictionary keys and make their respective values into Python objects of those types. Parameters: json_dict ( Dict [ str , Any ] ) \u2013 JSON dictionary that may contain keys in the format type.key_name (e.g. path.root_directory) with corresponding string values representing Python objects of that type. Returns: Dict [ str , Any ] \u2013 dict[str, Any]: Dictionary with both keys and Python object values derived from specially formatted JSON dictionary keys. Source code in src/pyobjson/data.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 def extract_typed_key_value_pairs ( json_dict : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\"Function to extract both keys and Python object types from specially formatted dictionary keys and make their respective values into Python objects of those types. Args: json_dict (Dict[str, Any]): JSON dictionary that may contain keys in the format type.key_name (e.g. path.root_directory) with corresponding string values representing Python objects of that type. Returns: dict[str, Any]: Dictionary with both keys and Python object values derived from specially formatted JSON dictionary keys. \"\"\" derived_key_value_pairs = {} for key , value in json_dict . items (): # check if key is formatted with a single \".\" to indicate a value type if key . count ( \".\" ) == 1 : type_name , key = key . split ( \".\" ) type_category = None if type_name . count ( \":\" ) == 1 : type_category , type_name = type_name . split ( \":\" ) if type_category == \"collection\" : if type_name == \"dict\" : # do nothing because JSON supports dictionaries pass elif type_name == \"list\" : # do nothing because JSON supports lists pass elif type_name == \"set\" : value = set ( value ) elif type_name == \"tuple\" : value = tuple ( value ) elif type_name == \"bytes\" or type_name == \"bytearray\" : value = b64decode ( value ) elif type_name == \"path\" : # handle posix paths value = Path ( value ) elif type_name == \"callable\" : # handle callables (functions, methods, etc.) # extract the callable components from a value with format module.callable::arg1:type1,arg2:type2 callable_path , callable_args = value . split ( \"::\" , 1 ) # extract the callable module and name module , callable_name = callable_path . rsplit ( \".\" , 1 ) # use the callable module and name to import the callable itself and set it to the value value = getattr ( import_module ( module ), callable_name ) elif type_name == \"datetime\" : # handle datetime objects value = datetime . fromisoformat ( value ) else : raise ValueError ( f \"JSON data ( { key } : { value } ) is not compatible with pyobjson.\" ) derived_key_value_pairs [ key ] = value else : # add key-value pair without modification if key is not formatted with a single \".\" to indicate a value type derived_key_value_pairs [ key ] = value return derived_key_value_pairs","title":"extract_typed_key_value_pairs"},{"location":"data/#src.pyobjson.data.serialize","text":"serialize ( obj , pyobjson_base_custom_subclasses ) Recursive function to serialize custom Python objects into nested dictionaries for conversion to JSON. Parameters: obj ( Any ) \u2013 Python object to serialize. pyobjson_base_custom_subclasses ( list [ Type ] ) \u2013 List of custom Python class subclasses. Returns: Any \u2013 dict[str, Any]: Serializable dictionary. Source code in src/pyobjson/data.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def serialize ( obj : Any , pyobjson_base_custom_subclasses : List [ Type ]) -> Any : \"\"\"Recursive function to serialize custom Python objects into nested dictionaries for conversion to JSON. Args: obj (Any): Python object to serialize. pyobjson_base_custom_subclasses (list[Type]): List of custom Python class subclasses. Returns: dict[str, Any]: Serializable dictionary. \"\"\" if type ( obj ) in pyobjson_base_custom_subclasses : serializable_obj = {} for att , val in unpack_custom_class_vars ( obj , pyobjson_base_custom_subclasses ) . items (): if isinstance ( val , dict ): att = f \"collection:dict. { att } \" elif isinstance ( val , ( list , set , tuple , bytes , bytearray )): att = f \"collection: { derive_custom_object_key ( val . __class__ ) } . { att } \" elif isinstance ( val , Path ): att = f \"path. { att } \" elif isinstance ( val , Callable ): att = f \"callable. { att } \" elif isinstance ( val , datetime ): att = f \"datetime. { att } \" serializable_obj [ att ] = serialize ( val , pyobjson_base_custom_subclasses ) return { derive_custom_object_key ( obj . __class__ ): serializable_obj } elif isinstance ( obj , dict ): return { k : serialize ( v , pyobjson_base_custom_subclasses ) for k , v in obj . items ()} elif isinstance ( obj , ( list , set , tuple )): return [ serialize ( v , pyobjson_base_custom_subclasses ) for v in obj ] elif isinstance ( obj , ( bytes , bytearray )): return b64encode ( obj ) . decode ( \"utf-8\" ) elif isinstance ( obj , Path ): return str ( obj ) elif isinstance ( obj , Callable ): return derive_custom_callable_value ( obj ) elif isinstance ( obj , datetime ): return obj . isoformat () else : return obj","title":"serialize"},{"location":"data/#src.pyobjson.data.deserialize","text":"deserialize ( json_data , pyobjson_base_custom_subclasses_by_key ) Recursive function to deserialize JSON into typed data structures for conversion to custom Python objects. Parameters: json_data ( Any ) \u2013 JSON data to be deserialized. pyobjson_base_custom_subclasses_by_key ( dict [ str , Type ] ) \u2013 Dictionary with snakecase strings of all subclasses of PythonObjectJson as keys and subclasses as values. Returns: obj ( Any ) \u2013 Object deserialized from JSON. Source code in src/pyobjson/data.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def deserialize ( json_data : Any , pyobjson_base_custom_subclasses_by_key : Dict [ str , Type ]) -> Any : \"\"\"Recursive function to deserialize JSON into typed data structures for conversion to custom Python objects. Args: json_data (Any): JSON data to be deserialized. pyobjson_base_custom_subclasses_by_key (dict[str, Type]): Dictionary with snakecase strings of all subclasses of PythonObjectJson as keys and subclasses as values. Returns: obj (Any): Object deserialized from JSON. \"\"\" base_subclasses : Dict [ str , Type ] = pyobjson_base_custom_subclasses_by_key if isinstance ( json_data , list ): # recursively deserialize all elements if json_data is a list return [ deserialize ( item , base_subclasses ) for item in json_data ] elif isinstance ( json_data , dict ): # recursively deserialize all values if json_data is a dictionary # noinspection PyUnboundLocalVariable if len ( json_data ) == 1 and ( single_key := next ( iter ( json_data . keys ()))) and single_key in base_subclasses : # check if json_data is a dict with only one key that matches a custom subclass for object derivation # noinspection PyPep8Naming ClassObject = base_subclasses [ single_key ] # retrieve custom subclass class_args = getfullargspec ( ClassObject . __init__ ) . args [ 1 :] # get __init__ arguments for custom subclass class_instance_attributes : Dict [ str , Any ] = json_data [ single_key ] # get JSON to be deserialized # create an instance of the custom subclass using the __init__ arguments class_instance = ClassObject ( ** { k : deserialize ( v , base_subclasses ) for k , v in extract_typed_key_value_pairs ( class_instance_attributes ) . items () if k in class_args } ) # assign the remaining class attributes to the created class instance vars ( class_instance ) . update ({ k : deserialize ( v , base_subclasses ) for k , v in extract_typed_key_value_pairs ( class_instance_attributes ) . items () }) return class_instance else : return { k : deserialize ( v , base_subclasses ) for k , v in extract_typed_key_value_pairs ( json_data ) . items ()} else : return json_data","title":"deserialize"},{"location":"deployment/","text":"Deployment \u00b6 Table of Contents \u00b6 Initial Deployment Subsequent Deployment Initial Deployment \u00b6 (Required for initial publication on PyPI as needed) Register a new account on PyPI (do the same for Test PyPI as needed). (Required for initial publication on PyPI) Configure API token authentication for PyPI by creating an API token (do the same for Test PyPI as needed) and copy the value of the API token. (Required for initial publication on PyPI) Create a .env file by running cp .env.template .env in the command line from the project root directory and paste the PyPI API token from the previous step as the value for UV_PUBLISH_TOKEN (this environment variable is used in the Makefile by uv publish to publish the package using uv ). (Optional after initial package publication on PyPI) Configure a new package-specific PyPI API token and update the above UV_PUBLISH_TOKEN environment variable in the .env to use it. (Optional if using Twine) Install twine (if not already installed) with uv add twine . (Optional if using custom domain for GitHub Pages) Follow the steps for managing a custom domain for GitHub Pages . If you want to use a subdomain, you should follow the steps for configuring a subdomain for GitHub Pages , which require the creation of a CNAME DNS record for your custom domain. Note : If you are using CloudFlare and you create a CNAME record for your GitHub Pages subdomain, you must turn off \u201cProxy status\u201d so that it is \u201cDNS only\u201d or else HTTPS will not work! Subsequent Deployment \u00b6 (Optional) Check pyproject.toml for latest dependency versions. (Optional) Update virtual machine with the latest dependencies ( make update in Makefile): uv sync --all-extras --dev Lint code with ruff ( make lint in Makefile): ruff check . Check code security with bandit ( make secure in Makefile): bandit -c pyproject.toml -r . (Optional) Run all pytest tests (see following commands for running subsets of tests) ( make test_code in Makefile): uv run pytest tests (Optional) Run all pytest tests verbosely : uv run pytest -v -s tests (Optional) Run all tests from pytest file: uv run pytest -v -s tests/test_pyobjson.py (Optional) Run specific test from pytest file: uv run pytest -v -s tests/test_pyobjson.py -k test_main (Optional) Test Python support using act for GitHub Actions: act -j build Note : If act is unable to locate Docker, make sure that the required /var/run/docker.sock symlink exists. If it does not, you can fix it by running: sudo ln -s \" $HOME /.docker/run/docker.sock\" /var/run/docker.sock ` Note : If you are running macOS on a devices with an M-series chip (Apple Silicon), you will need to specify linux/amd64 architecture when running act : act --container-architecture linux/amd64 -j build (Optional) Build the PyPI package independent of deployment: make build (Optional) Test packages for PyPI deployment: make verify_build (Optional) Check MkDocs documentation by serving it at http://localhost:8000/ locally: make test_docs (Optional) Build the PyPI package and MkDocs documentation independent of deployment: make docs Note : Running make test_docs from the previous step recreates the documentation without building the PyPI package. Create a git commit: git add . git commit -m 'commit message' Update the git tag with the new version ( git tag -a [tag_name/version] -m [message] ): git tag -a v1.0.0 -m 'release message' git push origin --tags (Optional) Test deployment by building the PyPI packages, recreating the documentation, and deploying to Test PyPI: make uv_test_deploy Deploy the package by building it, recreating the documentation, and deploying the package to PyPI: make uv_deploy Create a second git commit with updated version number and documentation and update the package git repository ( make git_post_deploy ): git add . git commit -m 'updated version number and documentation' git push","title":"Deployment"},{"location":"deployment/#deployment","text":"","title":"Deployment"},{"location":"deployment/#table-of-contents","text":"Initial Deployment Subsequent Deployment","title":"Table of Contents"},{"location":"deployment/#initial-deployment","text":"(Required for initial publication on PyPI as needed) Register a new account on PyPI (do the same for Test PyPI as needed). (Required for initial publication on PyPI) Configure API token authentication for PyPI by creating an API token (do the same for Test PyPI as needed) and copy the value of the API token. (Required for initial publication on PyPI) Create a .env file by running cp .env.template .env in the command line from the project root directory and paste the PyPI API token from the previous step as the value for UV_PUBLISH_TOKEN (this environment variable is used in the Makefile by uv publish to publish the package using uv ). (Optional after initial package publication on PyPI) Configure a new package-specific PyPI API token and update the above UV_PUBLISH_TOKEN environment variable in the .env to use it. (Optional if using Twine) Install twine (if not already installed) with uv add twine . (Optional if using custom domain for GitHub Pages) Follow the steps for managing a custom domain for GitHub Pages . If you want to use a subdomain, you should follow the steps for configuring a subdomain for GitHub Pages , which require the creation of a CNAME DNS record for your custom domain. Note : If you are using CloudFlare and you create a CNAME record for your GitHub Pages subdomain, you must turn off \u201cProxy status\u201d so that it is \u201cDNS only\u201d or else HTTPS will not work!","title":"Initial Deployment"},{"location":"deployment/#subsequent-deployment","text":"(Optional) Check pyproject.toml for latest dependency versions. (Optional) Update virtual machine with the latest dependencies ( make update in Makefile): uv sync --all-extras --dev Lint code with ruff ( make lint in Makefile): ruff check . Check code security with bandit ( make secure in Makefile): bandit -c pyproject.toml -r . (Optional) Run all pytest tests (see following commands for running subsets of tests) ( make test_code in Makefile): uv run pytest tests (Optional) Run all pytest tests verbosely : uv run pytest -v -s tests (Optional) Run all tests from pytest file: uv run pytest -v -s tests/test_pyobjson.py (Optional) Run specific test from pytest file: uv run pytest -v -s tests/test_pyobjson.py -k test_main (Optional) Test Python support using act for GitHub Actions: act -j build Note : If act is unable to locate Docker, make sure that the required /var/run/docker.sock symlink exists. If it does not, you can fix it by running: sudo ln -s \" $HOME /.docker/run/docker.sock\" /var/run/docker.sock ` Note : If you are running macOS on a devices with an M-series chip (Apple Silicon), you will need to specify linux/amd64 architecture when running act : act --container-architecture linux/amd64 -j build (Optional) Build the PyPI package independent of deployment: make build (Optional) Test packages for PyPI deployment: make verify_build (Optional) Check MkDocs documentation by serving it at http://localhost:8000/ locally: make test_docs (Optional) Build the PyPI package and MkDocs documentation independent of deployment: make docs Note : Running make test_docs from the previous step recreates the documentation without building the PyPI package. Create a git commit: git add . git commit -m 'commit message' Update the git tag with the new version ( git tag -a [tag_name/version] -m [message] ): git tag -a v1.0.0 -m 'release message' git push origin --tags (Optional) Test deployment by building the PyPI packages, recreating the documentation, and deploying to Test PyPI: make uv_test_deploy Deploy the package by building it, recreating the documentation, and deploying the package to PyPI: make uv_deploy Create a second git commit with updated version number and documentation and update the package git repository ( make git_post_deploy ): git add . git commit -m 'updated version number and documentation' git push","title":"Subsequent Deployment"},{"location":"readme/","text":"pyobjson - Python Object JSON Tool \u00b6 Utility library for serializing/deserializing custom Python objects to/from JSON. Do you like the Python Object JSON Tool? Star the repository on GitHub and please consider helping support its ongoing development: READ THE DOCS HERE! Detailed documentation can be found at https://pyobjson.wrencode.dev . Table of Contents \u00b6 About Dependencies Toolchain Usage Example Output Saving and Loading JSON Files MongoDB PostgreSQL About \u00b6 The Python Object JSON Tool is a utility library for serializing/deserializing custom Python objects to/from JSON. Dependencies \u00b6 The Python Object JSON Tool does not have any third-party dependencies to run the code. It has several development dependencies, which can be seen in the package pyproject.toml . Toolchain \u00b6 The below tools and resources are used as part of pyobjson: uv - package management ruff - code linting bandit - code security make - Makefile build automation MkDocs - package documentation python-dotenv - programmatic access to environment variables defined in a .env file pytest - code testing framework GitHub Actions - CI/CD act - GitHub Actions testing Usage \u00b6 The pyobjson package is designed to be used as a base class/parent class/superclass to your own custom Python classes in order to provide built-in, convenient serialization/deserialization functionality. Child classes/subclasses of pyobjson.base.PythonObjectJson will automatically have the following methods: pyobjson.base.PythonObjectJson.serialize() : Create a serializable dictionary from the class instance. pyobjson.base.PythonObjectJson.to_json_str() : Serialize the class instance to a JSON string. pyobjson.base.PythonObjectJson.from_json_str(json_str) : Load the class instance from a pyobjson -formatted JSON string. pyobjson.base.PythonObjectJson.save_to_json_file(json_file_path) : Save the class instance to a JSON file. pyobjson.base.PythonObjectJson.load_from_json_file(json_file_path) : Load the class instance from a pyobjson -formatted JSON file. Please reference the documentation at https://pyobjson.wrencode.dev for more detailed usage. Example \u00b6 from pyobjson.base import PythonObjectJson class ChildClass ( PythonObjectJson ): def __init__ ( self ): super () . __init__ () self . message = \"Hello, World!\" class ParentClass ( PythonObjectJson ): def __init__ ( self ): super () . __init__ () self . child_classes = [ ChildClass ()] parent_class = ParentClass () print ( parent_class . to_json_str ()) Output \u00b6 { \"__main__.parentclass\" : { \"collection:list.child_classes\" : [ { \"__main__.childclass\" : { \"message\" : \"Hello, World!\" } } ] } } The above example shows how pyobjson can be used to serialize arbitrary custom Python classes into JSON. Additionally, the above output JSON can be used to recreate an equivalent class instance by loading the JSON into a custom Python class instance. Saving and Loading \u00b6 The pyobjson.base.PythonObjectJson parent class also provides built-in methods to save/load arbitrary custom Python classes to/from JSON in several ways. JSON Files \u00b6 JSON files (using only Python built-in libraries) : Use the PythonObjectJson.save_to_json_file(json_file_path) and PythonObjectJson.load_from_json_file(json_file_path) methods to save/load your custom Python classes to JSON files. MongoDB \u00b6 MongoDB (using pymongo ) : COMING SOON! PostgreSQL \u00b6 PostgreSQL (using psycopg ) : COMING SOON!","title":"README"},{"location":"readme/#pyobjson-python-object-json-tool","text":"Utility library for serializing/deserializing custom Python objects to/from JSON. Do you like the Python Object JSON Tool? Star the repository on GitHub and please consider helping support its ongoing development: READ THE DOCS HERE! Detailed documentation can be found at https://pyobjson.wrencode.dev .","title":"pyobjson - Python Object JSON Tool"},{"location":"readme/#table-of-contents","text":"About Dependencies Toolchain Usage Example Output Saving and Loading JSON Files MongoDB PostgreSQL","title":"Table of Contents"},{"location":"readme/#about","text":"The Python Object JSON Tool is a utility library for serializing/deserializing custom Python objects to/from JSON.","title":"About"},{"location":"readme/#dependencies","text":"The Python Object JSON Tool does not have any third-party dependencies to run the code. It has several development dependencies, which can be seen in the package pyproject.toml .","title":"Dependencies"},{"location":"readme/#toolchain","text":"The below tools and resources are used as part of pyobjson: uv - package management ruff - code linting bandit - code security make - Makefile build automation MkDocs - package documentation python-dotenv - programmatic access to environment variables defined in a .env file pytest - code testing framework GitHub Actions - CI/CD act - GitHub Actions testing","title":"Toolchain"},{"location":"readme/#usage","text":"The pyobjson package is designed to be used as a base class/parent class/superclass to your own custom Python classes in order to provide built-in, convenient serialization/deserialization functionality. Child classes/subclasses of pyobjson.base.PythonObjectJson will automatically have the following methods: pyobjson.base.PythonObjectJson.serialize() : Create a serializable dictionary from the class instance. pyobjson.base.PythonObjectJson.to_json_str() : Serialize the class instance to a JSON string. pyobjson.base.PythonObjectJson.from_json_str(json_str) : Load the class instance from a pyobjson -formatted JSON string. pyobjson.base.PythonObjectJson.save_to_json_file(json_file_path) : Save the class instance to a JSON file. pyobjson.base.PythonObjectJson.load_from_json_file(json_file_path) : Load the class instance from a pyobjson -formatted JSON file. Please reference the documentation at https://pyobjson.wrencode.dev for more detailed usage.","title":"Usage"},{"location":"readme/#example","text":"from pyobjson.base import PythonObjectJson class ChildClass ( PythonObjectJson ): def __init__ ( self ): super () . __init__ () self . message = \"Hello, World!\" class ParentClass ( PythonObjectJson ): def __init__ ( self ): super () . __init__ () self . child_classes = [ ChildClass ()] parent_class = ParentClass () print ( parent_class . to_json_str ())","title":"Example"},{"location":"readme/#output","text":"{ \"__main__.parentclass\" : { \"collection:list.child_classes\" : [ { \"__main__.childclass\" : { \"message\" : \"Hello, World!\" } } ] } } The above example shows how pyobjson can be used to serialize arbitrary custom Python classes into JSON. Additionally, the above output JSON can be used to recreate an equivalent class instance by loading the JSON into a custom Python class instance.","title":"Output"},{"location":"readme/#saving-and-loading","text":"The pyobjson.base.PythonObjectJson parent class also provides built-in methods to save/load arbitrary custom Python classes to/from JSON in several ways.","title":"Saving and Loading"},{"location":"readme/#json-files","text":"JSON files (using only Python built-in libraries) : Use the PythonObjectJson.save_to_json_file(json_file_path) and PythonObjectJson.load_from_json_file(json_file_path) methods to save/load your custom Python classes to JSON files.","title":"JSON Files"},{"location":"readme/#mongodb","text":"MongoDB (using pymongo ) : COMING SOON!","title":"MongoDB"},{"location":"readme/#postgresql","text":"PostgreSQL (using psycopg ) : COMING SOON!","title":"PostgreSQL"},{"location":"tests/","text":"PyTest \u00b6 Modules: Name Description conftest Pytest top-level conftest.py. test_pyobjson Pytest test for Python Object JSON Tool code. conftest \u00b6 Pytest top-level conftest.py. Classes: Name Description ChildChildClass ChildChildClass for testing. ChildClass ChildClass for testing. ParentClass ParentClass for testing. Functions: Name Description external_function Function for testing. parent_class_with_nested_child_classes Create ParentClass instance for testing. parent_class_json_str Create JSON string from ParentClass instance for testing. ChildChildClass \u00b6 Bases: PythonObjectJson ChildChildClass for testing. Source code in tests/conftest.py 21 22 23 24 25 26 class ChildChildClass ( PythonObjectJson ): \"\"\"ChildChildClass for testing.\"\"\" def __init__ ( self , child_child_class_param : str ): super () . __init__ () self . child_child_class_param : str = child_child_class_param ChildClass \u00b6 Bases: PythonObjectJson ChildClass for testing. Source code in tests/conftest.py 29 30 31 32 33 34 35 36 37 class ChildClass ( PythonObjectJson ): \"\"\"ChildClass for testing.\"\"\" def __init__ ( self , child_child_class_list : List [ ChildChildClass ]): super () . __init__ () self . child_child_class_list : List [ ChildChildClass ] = child_child_class_list self . child_child_class_list_dict : Dict [ str , List [ ChildChildClass ]] = { \"child_child_class_list_1\" : child_child_class_list } ParentClass \u00b6 Bases: PythonObjectJson ParentClass for testing. Source code in tests/conftest.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class ParentClass ( PythonObjectJson ): \"\"\"ParentClass for testing.\"\"\" def __init__ ( self , child_class_dict : Dict [ str , ChildClass ], child_class_list : List [ ChildClass ], parent_class_set : Optional [ Set [ str ]], parent_class_tuple : Optional [ Tuple [ str ]], parent_class_bytes : Optional [ bytes ], parent_class_file : Optional [ Path ], parent_class_external_function : Optional [ Callable ], parent_class_datetime : Optional [ datetime ], ): super () . __init__ () self . child_class_dict : Dict [ str , ChildClass ] = child_class_dict self . child_class_list : List [ ChildClass ] = child_class_list self . parent_class_set : Set [ str ] = parent_class_set self . parent_class_tuple : Tuple [ str ] = parent_class_tuple self . parent_class_bytes : bytes = parent_class_bytes self . parent_class_file : Path = parent_class_file self . parent_class_external_function : Optional [ Callable ] = parent_class_external_function self . parent_class_datetime : datetime = parent_class_datetime external_function \u00b6 external_function ( param1 , param2 ) Function for testing. Source code in tests/conftest.py 16 17 18 def external_function ( param1 : str , param2 : str ): \"\"\"Function for testing.\"\"\" return f \" { param1 } . { param2 } \" parent_class_with_nested_child_classes \u00b6 parent_class_with_nested_child_classes () Create ParentClass instance for testing. Returns: ParentClass ( ParentClass ) \u2013 Instance of ParentClass. Source code in tests/conftest.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 @fixture ( scope = \"module\" ) def parent_class_with_nested_child_classes () -> ParentClass : \"\"\"Create ParentClass instance for testing. Returns: ParentClass: Instance of ParentClass. \"\"\" return ParentClass ( { \"child_class_1\" : ChildClass ([ ChildChildClass ( \"test_child_child_class_argument_in_dict\" )])}, [ ChildClass ([ ChildChildClass ( \"test_child_child_class_argument_in_list\" )])], { \"test_parent_class_collection_element\" }, ( \"test_parent_class_collection_element\" ,), b \"test_parent_class_collection_element\" , Path ( __name__ ), external_function , datetime ( 2024 , 1 , 1 , 0 , 0 , 0 ), ) parent_class_json_str \u00b6 parent_class_json_str () Create JSON string from ParentClass instance for testing. Returns: str ( str ) \u2013 JSON string derived from serialized ParentClass instance. Source code in tests/conftest.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 @fixture ( scope = \"module\" ) def parent_class_json_str () -> str : \"\"\"Create JSON string from ParentClass instance for testing. Returns: str: JSON string derived from serialized ParentClass instance. \"\"\" return json . dumps ( { \"conftest.parentclass\" : { \"collection:dict.child_class_dict\" : { \"child_class_1\" : { \"conftest.childclass\" : { \"collection:list.child_child_class_list\" : [ { \"conftest.childchildclass\" : { \"child_child_class_param\" : \"test_child_child_class_argument_in_dict\" } } ], \"collection:dict.child_child_class_list_dict\" : { \"child_child_class_list_1\" : [ { \"conftest.childchildclass\" : { \"child_child_class_param\" : \"test_child_child_class_argument_in_dict\" } } ] }, } } }, \"collection:list.child_class_list\" : [ { \"conftest.childclass\" : { \"collection:list.child_child_class_list\" : [ { \"conftest.childchildclass\" : { \"child_child_class_param\" : \"test_child_child_class_argument_in_list\" } } ], \"collection:dict.child_child_class_list_dict\" : { \"child_child_class_list_1\" : [ { \"conftest.childchildclass\" : { \"child_child_class_param\" : \"test_child_child_class_argument_in_list\" } } ] }, } } ], \"collection:set.parent_class_set\" : [ \"test_parent_class_collection_element\" ], \"collection:tuple.parent_class_tuple\" : [ \"test_parent_class_collection_element\" ], \"collection:bytes.parent_class_bytes\" : \"dGVzdF9wYXJlbnRfY2xhc3NfY29sbGVjdGlvbl9lbGVtZW50\" , \"path.parent_class_file\" : \"conftest\" , \"callable.parent_class_external_function\" : \"conftest.external_function::param1:str,param2:str\" , \"datetime.parent_class_datetime\" : \"2024-01-01T00:00:00\" , } }, ensure_ascii = False , indent = 2 , ) test_pyobjson \u00b6 Pytest test for Python Object JSON Tool code. Note Tests pyobjson.base module.","title":"PyTest"},{"location":"tests/#pytest","text":"Modules: Name Description conftest Pytest top-level conftest.py. test_pyobjson Pytest test for Python Object JSON Tool code.","title":"PyTest"},{"location":"tests/#tests.conftest","text":"Pytest top-level conftest.py. Classes: Name Description ChildChildClass ChildChildClass for testing. ChildClass ChildClass for testing. ParentClass ParentClass for testing. Functions: Name Description external_function Function for testing. parent_class_with_nested_child_classes Create ParentClass instance for testing. parent_class_json_str Create JSON string from ParentClass instance for testing.","title":"conftest"},{"location":"tests/#tests.conftest.ChildChildClass","text":"Bases: PythonObjectJson ChildChildClass for testing. Source code in tests/conftest.py 21 22 23 24 25 26 class ChildChildClass ( PythonObjectJson ): \"\"\"ChildChildClass for testing.\"\"\" def __init__ ( self , child_child_class_param : str ): super () . __init__ () self . child_child_class_param : str = child_child_class_param","title":"ChildChildClass"},{"location":"tests/#tests.conftest.ChildClass","text":"Bases: PythonObjectJson ChildClass for testing. Source code in tests/conftest.py 29 30 31 32 33 34 35 36 37 class ChildClass ( PythonObjectJson ): \"\"\"ChildClass for testing.\"\"\" def __init__ ( self , child_child_class_list : List [ ChildChildClass ]): super () . __init__ () self . child_child_class_list : List [ ChildChildClass ] = child_child_class_list self . child_child_class_list_dict : Dict [ str , List [ ChildChildClass ]] = { \"child_child_class_list_1\" : child_child_class_list }","title":"ChildClass"},{"location":"tests/#tests.conftest.ParentClass","text":"Bases: PythonObjectJson ParentClass for testing. Source code in tests/conftest.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class ParentClass ( PythonObjectJson ): \"\"\"ParentClass for testing.\"\"\" def __init__ ( self , child_class_dict : Dict [ str , ChildClass ], child_class_list : List [ ChildClass ], parent_class_set : Optional [ Set [ str ]], parent_class_tuple : Optional [ Tuple [ str ]], parent_class_bytes : Optional [ bytes ], parent_class_file : Optional [ Path ], parent_class_external_function : Optional [ Callable ], parent_class_datetime : Optional [ datetime ], ): super () . __init__ () self . child_class_dict : Dict [ str , ChildClass ] = child_class_dict self . child_class_list : List [ ChildClass ] = child_class_list self . parent_class_set : Set [ str ] = parent_class_set self . parent_class_tuple : Tuple [ str ] = parent_class_tuple self . parent_class_bytes : bytes = parent_class_bytes self . parent_class_file : Path = parent_class_file self . parent_class_external_function : Optional [ Callable ] = parent_class_external_function self . parent_class_datetime : datetime = parent_class_datetime","title":"ParentClass"},{"location":"tests/#tests.conftest.external_function","text":"external_function ( param1 , param2 ) Function for testing. Source code in tests/conftest.py 16 17 18 def external_function ( param1 : str , param2 : str ): \"\"\"Function for testing.\"\"\" return f \" { param1 } . { param2 } \"","title":"external_function"},{"location":"tests/#tests.conftest.parent_class_with_nested_child_classes","text":"parent_class_with_nested_child_classes () Create ParentClass instance for testing. Returns: ParentClass ( ParentClass ) \u2013 Instance of ParentClass. Source code in tests/conftest.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 @fixture ( scope = \"module\" ) def parent_class_with_nested_child_classes () -> ParentClass : \"\"\"Create ParentClass instance for testing. Returns: ParentClass: Instance of ParentClass. \"\"\" return ParentClass ( { \"child_class_1\" : ChildClass ([ ChildChildClass ( \"test_child_child_class_argument_in_dict\" )])}, [ ChildClass ([ ChildChildClass ( \"test_child_child_class_argument_in_list\" )])], { \"test_parent_class_collection_element\" }, ( \"test_parent_class_collection_element\" ,), b \"test_parent_class_collection_element\" , Path ( __name__ ), external_function , datetime ( 2024 , 1 , 1 , 0 , 0 , 0 ), )","title":"parent_class_with_nested_child_classes"},{"location":"tests/#tests.conftest.parent_class_json_str","text":"parent_class_json_str () Create JSON string from ParentClass instance for testing. Returns: str ( str ) \u2013 JSON string derived from serialized ParentClass instance. Source code in tests/conftest.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 @fixture ( scope = \"module\" ) def parent_class_json_str () -> str : \"\"\"Create JSON string from ParentClass instance for testing. Returns: str: JSON string derived from serialized ParentClass instance. \"\"\" return json . dumps ( { \"conftest.parentclass\" : { \"collection:dict.child_class_dict\" : { \"child_class_1\" : { \"conftest.childclass\" : { \"collection:list.child_child_class_list\" : [ { \"conftest.childchildclass\" : { \"child_child_class_param\" : \"test_child_child_class_argument_in_dict\" } } ], \"collection:dict.child_child_class_list_dict\" : { \"child_child_class_list_1\" : [ { \"conftest.childchildclass\" : { \"child_child_class_param\" : \"test_child_child_class_argument_in_dict\" } } ] }, } } }, \"collection:list.child_class_list\" : [ { \"conftest.childclass\" : { \"collection:list.child_child_class_list\" : [ { \"conftest.childchildclass\" : { \"child_child_class_param\" : \"test_child_child_class_argument_in_list\" } } ], \"collection:dict.child_child_class_list_dict\" : { \"child_child_class_list_1\" : [ { \"conftest.childchildclass\" : { \"child_child_class_param\" : \"test_child_child_class_argument_in_list\" } } ] }, } } ], \"collection:set.parent_class_set\" : [ \"test_parent_class_collection_element\" ], \"collection:tuple.parent_class_tuple\" : [ \"test_parent_class_collection_element\" ], \"collection:bytes.parent_class_bytes\" : \"dGVzdF9wYXJlbnRfY2xhc3NfY29sbGVjdGlvbl9lbGVtZW50\" , \"path.parent_class_file\" : \"conftest\" , \"callable.parent_class_external_function\" : \"conftest.external_function::param1:str,param2:str\" , \"datetime.parent_class_datetime\" : \"2024-01-01T00:00:00\" , } }, ensure_ascii = False , indent = 2 , )","title":"parent_class_json_str"},{"location":"tests/#tests.test_pyobjson","text":"Pytest test for Python Object JSON Tool code. Note Tests pyobjson.base module.","title":"test_pyobjson"},{"location":"utils/","text":"Utilities \u00b6 Python Object JSON Tool pyobjson.utils module. Attributes: __author__ ( str ) \u2013 Python package template author. __email__ ( str ) \u2013 Python package template author email. Functions: Name Description derive_custom_object_key Utility function to derive a key for a custom object representing the fully qualified name of that object. derive_custom_callable_value Utility function to derive a string value from a custom callable object. derive_custom_object_key \u00b6 derive_custom_object_key ( custom_object , as_lower = True ) Utility function to derive a key for a custom object representing the fully qualified name of that object. Parameters: custom_object ( Type ) \u2013 The custom object for which to derive a key. as_lower ( bool , default: True ) \u2013 Whether the derived key should be returned as a lower case string. Returns: str ( str ) \u2013 The fully qualified name of the object in lowercase (e.g. module.submodule.object). Source code in src/pyobjson/utils.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def derive_custom_object_key ( custom_object : Union [ Type , Callable ], as_lower : bool = True ) -> str : \"\"\"Utility function to derive a key for a custom object representing the fully qualified name of that object. Args: custom_object (Type): The custom object for which to derive a key. as_lower (bool, optional): Whether the derived key should be returned as a lower case string. Returns: str: The fully qualified name of the object in lowercase (e.g. module.submodule.object). \"\"\" # avoid including module if no module exists or the object is in the Python builtins if ( obj_module := getattr ( custom_object , \"__module__\" , None )) and obj_module != \"builtins\" : return ( f \" { obj_module . lower () } . { custom_object . __qualname__ . lower () } \" if as_lower else f \" { obj_module } . { custom_object . __qualname__ } \" ) else : return custom_object . __qualname__ . lower () if as_lower else custom_object . __qualname__ derive_custom_callable_value \u00b6 derive_custom_callable_value ( custom_callable ) Utility function to derive a string value from a custom callable object. Parameters: custom_callable ( Callable ) \u2013 Custom callable object for which to derive a string representation value. Returns: str ( str ) \u2013 A string representing the custom callable object that can be used to import and call that object. Source code in src/pyobjson/utils.py 37 38 39 40 41 42 43 44 45 46 47 48 def derive_custom_callable_value ( custom_callable : Callable ) -> str : \"\"\"Utility function to derive a string value from a custom callable object. Args: custom_callable (Callable): Custom callable object for which to derive a string representation value. Returns: str: A string representing the custom callable object that can be used to import and call that object. \"\"\" arg_spec_str = \",\" . join ([ f \" { k } : { v . __name__ } \" for k , v in getfullargspec ( custom_callable ) . annotations . items ()]) return f \" { derive_custom_object_key ( custom_callable ) } :: { arg_spec_str } \"","title":"Utilities"},{"location":"utils/#utilities","text":"Python Object JSON Tool pyobjson.utils module. Attributes: __author__ ( str ) \u2013 Python package template author. __email__ ( str ) \u2013 Python package template author email. Functions: Name Description derive_custom_object_key Utility function to derive a key for a custom object representing the fully qualified name of that object. derive_custom_callable_value Utility function to derive a string value from a custom callable object.","title":"Utilities"},{"location":"utils/#src.pyobjson.utils.derive_custom_object_key","text":"derive_custom_object_key ( custom_object , as_lower = True ) Utility function to derive a key for a custom object representing the fully qualified name of that object. Parameters: custom_object ( Type ) \u2013 The custom object for which to derive a key. as_lower ( bool , default: True ) \u2013 Whether the derived key should be returned as a lower case string. Returns: str ( str ) \u2013 The fully qualified name of the object in lowercase (e.g. module.submodule.object). Source code in src/pyobjson/utils.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def derive_custom_object_key ( custom_object : Union [ Type , Callable ], as_lower : bool = True ) -> str : \"\"\"Utility function to derive a key for a custom object representing the fully qualified name of that object. Args: custom_object (Type): The custom object for which to derive a key. as_lower (bool, optional): Whether the derived key should be returned as a lower case string. Returns: str: The fully qualified name of the object in lowercase (e.g. module.submodule.object). \"\"\" # avoid including module if no module exists or the object is in the Python builtins if ( obj_module := getattr ( custom_object , \"__module__\" , None )) and obj_module != \"builtins\" : return ( f \" { obj_module . lower () } . { custom_object . __qualname__ . lower () } \" if as_lower else f \" { obj_module } . { custom_object . __qualname__ } \" ) else : return custom_object . __qualname__ . lower () if as_lower else custom_object . __qualname__","title":"derive_custom_object_key"},{"location":"utils/#src.pyobjson.utils.derive_custom_callable_value","text":"derive_custom_callable_value ( custom_callable ) Utility function to derive a string value from a custom callable object. Parameters: custom_callable ( Callable ) \u2013 Custom callable object for which to derive a string representation value. Returns: str ( str ) \u2013 A string representing the custom callable object that can be used to import and call that object. Source code in src/pyobjson/utils.py 37 38 39 40 41 42 43 44 45 46 47 48 def derive_custom_callable_value ( custom_callable : Callable ) -> str : \"\"\"Utility function to derive a string value from a custom callable object. Args: custom_callable (Callable): Custom callable object for which to derive a string representation value. Returns: str: A string representing the custom callable object that can be used to import and call that object. \"\"\" arg_spec_str = \",\" . join ([ f \" { k } : { v . __name__ } \" for k , v in getfullargspec ( custom_callable ) . annotations . items ()]) return f \" { derive_custom_object_key ( custom_callable ) } :: { arg_spec_str } \"","title":"derive_custom_callable_value"}]}